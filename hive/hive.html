<!DOCTYPE html>
<html lang="zh_cn">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<meta name="keywords" content="TDP, Hadoop, bigdata, Spark">
<meta name="author" content="湖南天云魔方数据科技有限公司">
<title>Hive 使用手册</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<style>
/* Pygments styles disabled. Pygments is not available. */
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Hive 使用手册</h1>
<div class="details">
<span id="author" class="author">湖南天云魔方数据科技有限公司</span><br>
<span id="revdate">2015</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#hive-concept">1. Hive 基本原理</a>
<ul class="sectlevel2">
<li><a href="#_hive_架构">1.1. Hive 架构</a></li>
<li><a href="#hive-and-hadoop">1.2. Hive 和 Hadoop 的关系</a></li>
<li><a href="#hive-rdbms">1.3. Hive 和传统关系数据库的异同</a></li>
<li><a href="#hive-metastore">1.4. Hive 元数据库</a></li>
<li><a href="#data-units">1.5. Hive 数据组织结构</a></li>
<li><a href="#type-system">1.6. 数据类型</a></li>
<li><a href="#built-in-operators">1.7. 内置的操作符</a></li>
<li><a href="#built-in-functions">1.8. 内置的函数</a></li>
</ul>
</li>
<li><a href="#hive-getting-started">2. Hive 快速入门</a>
<ul class="sectlevel2">
<li><a href="#running-hive">2.1. 运行 Hive</a></li>
<li><a href="#runtime-configuration">2.2. 运行时配置</a></li>
<li><a href="#hive-mapred-local-mode">2.3. Hive MapReduce 以及本地模式</a></li>
<li><a href="#hive-logging">2.4. Hive 日志</a></li>
<li><a href="#ddl-operations">2.5. DDL 操作</a></li>
<li><a href="#dml-operations">2.6. DML 操作</a></li>
<li><a href="#sql-operations">2.7. SQL 操作</a></li>
<li><a href="#simple-example-use-cases">2.8. 简单用户使用案例</a></li>
</ul>
</li>
<li><a href="#_hive_ddl">3. Hive DDL</a>
<ul class="sectlevel2">
<li><a href="#_概述">3.1. 概述</a></li>
<li><a href="#_关键字">3.2. 关键字</a></li>
<li><a href="#_数据库定义">3.3. 数据库定义</a></li>
<li><a href="#_表定义">3.4. 表定义</a></li>
<li><a href="#_修改表_分区_字段">3.5. 修改表/分区/字段</a></li>
<li><a href="#_show">3.6. SHOW</a></li>
<li><a href="#_describe">3.7. Describe</a></li>
</ul>
</li>
<li><a href="#hive_dml">4. Hive DML</a>
<ul class="sectlevel2">
<li><a href="#_概述_2">4.1. 概述</a></li>
<li><a href="#_加载文件到表">4.2. 加载文件到表</a></li>
<li><a href="#_把查询结果插入数据到表">4.3. 把查询结果插入数据到表</a></li>
<li><a href="#_把查询结果写入文件系统">4.4. 把查询结果写入文件系统</a></li>
<li><a href="#_从_sql_插入数据到表">4.5. 从 SQL 插入数据到表</a></li>
<li><a href="#_更新">4.6. 更新</a></li>
<li><a href="#_删除">4.7. 删除</a></li>
</ul>
</li>
<li><a href="#hive_udf">5. Hive 自定义函数</a>
<ul class="sectlevel2">
<li><a href="#_内建函数">5.1. 内建函数</a></li>
<li><a href="#_内建的聚合函数">5.2. 内建的聚合函数</a></li>
<li><a href="#_内置的表生成函数">5.3. 内置的表生成函数</a></li>
</ul>
</li>
<li><a href="#hive_tuning">6. Hive 性能调优</a>
<ul class="sectlevel2">
<li><a href="#_hive_架构概述">6.1. Hive 架构概述</a></li>
<li><a href="#_hive_高性能最佳实践">6.2. Hive 高性能最佳实践</a></li>
<li><a href="#_使用列统计和_cbo">6.3. 使用列统计和 CBO</a></li>
<li><a href="#_巧妙设计数据存储">6.4. 巧妙设计数据存储</a></li>
<li><a href="#_使用队列来更好的管理负载">6.5. 使用队列来更好的管理负载</a></li>
<li><a href="#_内存配置指南">6.6. 内存配置指南</a></li>
<li><a href="#_查询优化">6.7. 查询优化</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="hive-concept">1. Hive 基本原理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hive 是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 QL，它允许熟悉 SQL 的用户查询数据。同时，这个语言也允许熟悉 MapReduce 开发者的开发自定义的 mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作。</p>
</div>
<div class="sect2">
<h3 id="_hive_架构">1.1. Hive 架构</h3>
<div class="imageblock">
<div class="content">
<img src="images/hive-arch-da1c4.png" alt="Hive架构">
</div>
</div>
<div class="paragraph">
<p>Hive 的结构可以分为以下几部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用户接口：包括 CLI, Client, WUI</p>
</li>
<li>
<p>元数据存储。通常是存储在关系数据库如 mysql, derby 中</p>
</li>
<li>
<p>解释器、编译器、优化器、执行器</p>
</li>
<li>
<p>Hadoop：用 HDFS 进行存储，利用 MapReduce 进行计算</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>用户接口主要有三个：CLI，Client 和 WUI。其中最常用的是 CLI，Cli 启动的时候，会同时启动一个 Hive 副本。Client 是 Hive 的客户端，用户连接至 Hive Server。在启动 Client 模式的时候，需要指出 Hive Server 所在节点，并且在该节点启动 Hive Server。 WUI 是通过浏览器访问 Hive。</p>
</li>
<li>
<p>Hive 将元数据存储在数据库中，如 mysql、derby。Hive 中的元数据包括表的名字，表的列和分区及其属性，表的属性（是否为外部表等），表的数据所在目录等。</p>
</li>
<li>
<p>解释器、编译器、优化器完成 HQL 查询语句从词法分析、语法分析、编译、优化以及查询计划的生成。生成的查询计划存储在 HDFS 中，并在随后有 MapReduce 调用执行。</p>
</li>
<li>
<p>Hive 的数据存储在 HDFS 中，大部分的查询由 MapReduce 完成（包含 * 的查询，比如 select * from tbl 不会生成 MapRedcue 任务）。</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="hive-and-hadoop">1.2. Hive 和 Hadoop 的关系</h3>
<div class="imageblock">
<div class="content">
<img src="images/hive-arch-03bcc.png" alt="hive arch 03bcc">
</div>
</div>
<div class="paragraph">
<p>Hive 构建在 Hadoop 之上，</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HQL 中对查询语句的解释、优化、生成查询计划是由 Hive 完成的</p>
</li>
<li>
<p>所有的数据都是存储在 Hadoop 中</p>
</li>
<li>
<p>查询计划被转化为 MapReduce 任务，在 Hadoop 中执行（有些查询没有 MR 任务，如：select * from table）</p>
</li>
<li>
<p>Hadoop和Hive都是用UTF-8编码的</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="hive-rdbms">1.3. Hive 和传统关系数据库的异同</h3>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">Hive</th>
<th class="tableblock halign-left valign-top">RDBMS</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">查询语言</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SQL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据存储</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HDFS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">裸设备或本地文件系统</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">索引</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MapReduce/Tez</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Executor</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行延迟</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">高</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">低</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理数据规模</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小</p></td>
</tr>
</tbody>
</table>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>查询语言。由于 SQL 被广泛的应用在数据仓库中，因此，专门针对 Hive 的特性设计了类 SQL 的查询语言 HQL。熟悉 SQL 开发的开发者可以很方便的使用 Hive 进行开发。</p>
</li>
<li>
<p>数据存储位置。Hive 是建立在 Hadoop 之上的，所有 Hive 的数据都是存储在 HDFS 中的。而数据库则可以将数据保存在块设备或者本地文件系统中。</p>
</li>
<li>
<p>数据格式。Hive 中没有定义专门的数据格式，数据格式可以由用户指定，用户定义数据格式需要指定三个属性：列分隔符（通常为空格、”\t”、”\x001″）、行分隔符（”\n”）以及读取文件数据的方法（Hive 中默认有三个文件格式 TextFile，SequenceFile 以及 RCFile）。由于在加载数据的过程中，不需要从用户数据格式到 Hive 定义的数据格式的转换，因此，Hive 在加载的过程中不会对数据本身进行任何修改，而只是将数据内容复制或者移动到相应的 HDFS 目录中。而在数据库中，不同的数据库有不同的存储引擎，定义了自己的数据格式。所有数据都会按照一定的组织存储，因此，数据库加载数据的过程会比较耗时。</p>
</li>
<li>
<p>数据更新。由于 Hive 是针对数据仓库应用设计的，而数据仓库的内容是读多写少的。因此，Hive 中不支持对数据的改写和添加，所有的数据都是在加载的时候中确定好的。而数据库中的数据通常是需要经常进行修改的，因此可以使用 INSERT INTO &#8230;&#8203;  VALUES 添加数据，使用 UPDATE &#8230;&#8203; SET 修改数据。</p>
</li>
<li>
<p>索引。之前已经说过，Hive 在加载数据的过程中不会对数据进行任何处理，甚至不会对数据进行扫描，因此也没有对数据中的某些 Key 建立索引。Hive 要访问数据中满足条件的特定值时，需要暴力扫描整个数据，因此访问延迟较高。由于 MapReduce 的引入， Hive 可以并行访问数据，因此即使没有索引，对于大数据量的访问，Hive 仍然可以体现出优势。数据库中，通常会针对一个或者几个列建立索引，因此对于少量的特定条件的数据的访问，数据库可以有很高的效率，较低的延迟。由于数据的访问延迟较高，决定了 Hive 不适合在线数据查询。</p>
</li>
<li>
<p>执行。Hive 中大多数查询的执行是通过 Hadoop 提供的 MapReduce 来实现的（类似 select * from tbl 的查询不需要 MapReduce）。而数据库通常有自己的执行引擎。</p>
</li>
<li>
<p>执行延迟。之前提到，Hive 在查询数据的时候，由于没有索引，需要扫描整个表，因此延迟较高。另外一个导致 Hive 执行延迟高的因素是 MapReduce 框架。由于 MapReduce 本身具有较高的延迟，因此在利用 MapReduce 执行 Hive 查询时，也会有较高的延迟。相对的，数据库的执行延迟较低。当然，这个低是有条件的，即数据规模较小，当数据规模大到超过数据库的处理能力的时候，Hive 的并行计算显然能体现出优势。</p>
</li>
<li>
<p>可扩展性。由于 Hive 是建立在 Hadoop 之上的，因此 Hive 的可扩展性是和 Hadoop 的可扩展性是一致的（世界上最大的 Hadoop 集群在 Yahoo!，2009年的规模在 4000 台节点左右）。而数据库由于 ACID 语义的严格限制，扩展行非常有限。目前最先进的并行数据库 Oracle 在理论上的扩展能力也只有 100 台左右。</p>
</li>
<li>
<p>数据规模。由于 Hive 建立在集群上并可以利用 MapReduce 进行并行计算，因此可以支持很大规模的数据；对应的，数据库可以支持的数据规模较小。</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="hive-metastore">1.4. Hive 元数据库</h3>
<div class="paragraph">
<p>Hive 将元数据存储在 RDBMS 中,一般常用的有 MySQL,PostgreSQL 和 Derby，Derby一般用于测试环境，适应于低负载的情况。在生成环境下，我们推荐使用 MySQL 或 PostgreSQL 之类的传统关系型数据库。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">表名</th>
<th class="tableblock halign-left valign-top">说明</th>
<th class="tableblock halign-left valign-top">关联键</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BUCKETING_COLS</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">COLUMNS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hive表字段信息(字段注释，字段名，字段类型，字段序号)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SD_ID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DBS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">元数据库信息，存放HDFS路径信息</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DB_ID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PARTITION_KEYS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hive分区表分区键</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PART_ID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SDS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有hive表、表分区所对应的hdfs数据目录和数据格式。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SD_ID,SERDE_ID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SD_PARAMS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">序列化反序列化信息，如行分隔符、列分隔符、NULL的表示字符等</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SERDE_ID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SEQUENCE_TABLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SEQUENCE_TABLE表保存了hive对象的下一个可用ID，如 <code>org.apache.hadoop.hive.metastore.model.MTable</code>, 21，则下一个新创建的hive表其TBL_ID就是21，同时SEQUENCE_TABLE表中271786被更新为26(这里每次都是+5?)。同样，COLUMN，PARTITION等都有相应的记录</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SERDES</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SERDE_PARAMS</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SORT_COLS</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TABLE_PARAMS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表级属性，如是否外部表，表注释等</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TBL_ID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TBLS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有hive表的基本信息</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TBL_ID,SD_ID</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>从上面几张表的内容来看，hive整个创建表的过程已经比较清楚了
1.	解析用户提交hive语句，对其进行解析，分解为表、字段、分区等hive对象
2.	根据解析到的信息构建对应的表、字段、分区等对象，从SEQUENCE_TABLE中获取构建对象的最新ID，与构建对象信息(名称，类型等)一同通过DAO方法写入到元数据表中去，成功后将SEQUENCE_TABLE中对应的最新ID+5。
实际上我们常见的RDBMS都是通过这种方法进行组织的，典型的如postgresql，其系统表中和hive元数据一样裸露了这些id信息(oid,cid等),而Oracle等商业化的系统则隐藏了这些具体的ID。通过这些元数据我们可以很容易的读到数据诸如创建一个表的数据字典信息，比如导出建表语名等。</p>
</div>
</div>
<div class="sect2">
<h3 id="data-units">1.5. Hive 数据组织结构</h3>
<div class="paragraph">
<p>Hive 的数据组织成以下结构：</p>
</div>
<div class="paragraph">
<div class="title">数据库(Database)</div>
<p>充当命名空间的功能，以避免表、视图、分区、字段的冲突。数据库也可以用来针对用户或者用户组设定在其上的安全配置。和传统关系型数据的 database 概念相同
.表(Table)
表是有相同模式的数据集合。和传统关系型数据库的 table 概念类似。
.分区(Partitions)
每一个表可以有一个或多个分区键，分区键决定数据如何存储，同时也使得用户可以高效的查询到特定的记录。比如对于字符串类型的分区键 'date_partition' 和 字符串类型的分区键 'country_partition' ，分区键的唯一值确定了一个分区表。
比如所有日期为 '2009-12-15' ，来自 'US' 的记录都会保存在一个分区表中。因此，如果你分析 '2009-12-15' 这条所有来自 'US' 的记录，那么系统只需要读取这一个分区表即可。
.桶或族(Buckets/Clusters)
每个分区表中的数据还可以按照针对某列求散列的方式划分到不同的桶里。</p>
</div>
<div class="paragraph">
<p>注意，对一个表而言，分区和桶并不是必须的，但这些数据组织的方式使得系统在清空表数据和查询数据时都能带来效率的提升。</p>
</div>
</div>
<div class="sect2">
<h3 id="type-system">1.6. 数据类型</h3>
<div class="paragraph">
<p>Hive 支持的数据类型分为基本类型和复杂数据类型。更多的详细内容可以参考link:[hive-data-types]，这里简单描述。</p>
</div>
<div class="sect3">
<h4 id="primitive-types">1.6.1. 基本数据类型</h4>
<div class="ulist">
<ul>
<li>
<p>整型</p>
<div class="ulist">
<ul>
<li>
<p>TINYINT&#8201;&#8212;&#8201;1字节整数</p>
</li>
<li>
<p>SMALLINT&#8201;&#8212;&#8201;2字节整数</p>
</li>
<li>
<p>INT&#8201;&#8212;&#8201;4字节整数</p>
</li>
<li>
<p>BIGINT&#8201;&#8212;&#8201;8字节整数</p>
</li>
</ul>
</div>
</li>
<li>
<p>布尔类型</p>
<div class="ulist">
<ul>
<li>
<p>BOOLEAN&#8201;&#8212;&#8201;True/False</p>
</li>
</ul>
</div>
</li>
<li>
<p>浮点数</p>
<div class="ulist">
<ul>
<li>
<p>FLOAT&#8201;&#8212;&#8201;单精度</p>
</li>
<li>
<p>DOUBLE&#8201;&#8212;&#8201;双精度</p>
</li>
</ul>
</div>
</li>
<li>
<p>定点数</p>
<div class="ulist">
<ul>
<li>
<p>DECIMAL&#8201;&#8212;&#8201;固定整数位和小数位的数字</p>
</li>
</ul>
</div>
</li>
<li>
<p>字符类型</p>
<div class="ulist">
<ul>
<li>
<p>STRING&#8201;&#8212;&#8201;特定字符集的字符序列</p>
</li>
<li>
<p>VARCHAR&#8201;&#8212;&#8201;特定字符集中有最大长度限定的字符序列</p>
</li>
<li>
<p>CHAR&#8201;&#8212;&#8201;特定字符集中有固定长度的字符序列</p>
</li>
</ul>
</div>
</li>
<li>
<p>日期和时间类型</p>
<div class="ulist">
<ul>
<li>
<p>TIMESTAMP&#8201;&#8212;&#8201;时间戳，精确到纳秒</p>
</li>
<li>
<p>DATE&#8201;&#8212;&#8201;日期</p>
</li>
</ul>
</div>
</li>
<li>
<p>二进制类型</p>
<div class="ulist">
<ul>
<li>
<p>BINARY&#8201;&#8212;&#8201;字节序列组合</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="complex-types">1.6.2. 复杂数据类型</h4>
<div class="paragraph">
<p>复杂数据类型建立在基本数据类型的基础上，他是多个基本数据类型的联合体：
.Structs
该类型里的所有元素采取点(.)记号方式访问。比如，对已一个字段 c 的类型为 <code>STRUCT{a INT; b INT}</code> ，那么元素 a 的访问方式就是 'c.a'
.Map(key-value对)
结构内的元素采取['元素名称']方式访问，比如对于字段 M 包含有 <code>'group'&#8594;gid</code> ，那么 'gid' 值可以通过 <code>M['group']</code> 方式获得。
.Array(带索引的列表)
数组(Array)的元素必须是同一类型，每个元素使用索引位置 '[n]' 方式访问。 'n' 为非0整数。比如对于一个包含 <code>['a','b','c']</code> 的字段 A，那么 'A[1]' 返回的就是 'b'</p>
</div>
<div class="paragraph">
<p>复杂数据类型可以有任意层级，可以递归创建。比如对一个类型 'User'，我们可以由以下类型组成：
* gender&#8201;&#8212;&#8201;字符创(STRING)类型
* active&#8201;&#8212;&#8201;布尔类型</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="built-in-operators">1.7. 内置的操作符</h3>
<div class="paragraph">
<p>Hive 内置了各种操作符用于条件查询时的过滤。</p>
</div>
<div class="paragraph">
<div class="title">关系操作符</div>
<p>以下操作符比较传递过来的操作数，然后返回 TRUE 或 FALSE</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">关系操作符</th>
<th class="tableblock halign-left valign-top">操作数类型</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A = B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有基本数据类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果表达式 A 等于 表达式 B，则返回 TRUE；否则返回 FALSE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A != B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有基本数据类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果表达式 A 不等于 表达式 B，则返回 TRUE；否则返回 FALSE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A &lt; B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有基本数据类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果表达式 A 小于 表达式 B，则返回 TRUE；否则返回 FALSE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A &#8656; B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有基本数据类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果表达式 A 小于等于 表达式 B，则返回 TRUE；否则返回 FALSE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A &gt; B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有基本数据类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果表达式 A 大于 表达式 B，则返回 TRUE；否则返回 FALSE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A &gt;= B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有基本数据类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果表达式 A 大于等于 表达式 B，则返回 TRUE；否则返回 FALSE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A IS NULL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果表达式 A 等于 NULL，则返回 TRUE；否则返回 FALSE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A IS NOT NULL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有数据类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果表达式 A 不等于 NULL，则返回 TRUE；否则返回 FALSE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A LIKE B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果 字符串 A 能匹配 SQL 简单正则表达式 B，则返回 TRUE；否则返回 FALSE。B 里的 _ 字符表示匹配任意一个字符， % 表示匹配任意数量的字符。比如 <code>'foobar' LIKE 'foo'</code> 返回 FALSE，但 <code>'foobar' LIKE 'foo%'</code> 则返回 TRUE。如果要匹配 _ , % 这些字符，需要使用转义符号 '\'。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A RLIKE B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果 A 或者 B 为 NULL ，则返回 NULL，如果 A 的任意字串（可能是空串）匹配 Java 正则表达式 B，则返回 TRUE，否则为 FALSE。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A REGEXP B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">和 RLIKE 相同</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<div class="title">算术操作符</div>
<p>以下操作符支持各种通用操作数上的算术操作。所有这些操作都返回数字类型</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">算术操作符</th>
<th class="tableblock halign-left valign-top">操作数</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A + B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有数字类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">给出 A 加 B 的结果，结果类型和操作数的类型或操作数的父类型相同；比如每个整数也属于浮点数，所以当一个浮点数 + 一个整数时，返回的数据类型是浮点数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A - B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有数字类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">给出 A 减 B 的结果，结果类型和操作数的类型或操作数的父类型相同；比如每个整数也属于浮点数，所以当一个浮点数 - 一个整数时，返回的数据类型是浮点数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A * B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有数字类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">给出 A 乘以 B 的结果，结果类型和操作数的类型或操作数的父类型相同；</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A /B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有数字类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">给出 A 除以 B 的结果，结果类型为 A 或 B 的类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A % B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有数字类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">给出 A 模 B 的结果，也就是 A 除以 B 的余数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A &amp; B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有数字类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">给出 A 和 B 按位与(AND)的结果</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有数字类型</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">给出 A 和 B 按位或(OR)的结果</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A ^ B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有数字类型</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">给出 A 和 B 按位异或(XOR)的结果</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">~A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有数字类型</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<div class="title">逻辑操作符</div>
<p>以下操作符支持逻辑表达式的创建，所有结果返回为布尔值</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">逻辑操作符</th>
<th class="tableblock halign-left valign-top">操作数</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A AND B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果 A 和 B 都为 TRUE，则返回为 TRUE； 否则返回为 FALSE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A &amp;&amp; B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">和 A AND B 相同</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A OR B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A 或 B 为 TRUE，则返回为 TRUE；否则返回 FALSE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">B</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类似 A OR B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NOT A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果 A 为 False ，则返回为 TRUE；否则返回 FALSE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!A</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<div class="title">复杂数据类型上的操作符</div>
<p>以下操作符提供访问复杂数据类型上的元素的访问方式</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">操作符</th>
<th class="tableblock halign-left valign-top">操作数类型</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A[n]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A 是一个数组(Array),n 为整数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回数组里某一个元素，第一个元素的索引为0.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">M[key]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">M 是一个映射(Map(k,v))</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回键为 key 的值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">S.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">S 是一个结构(Struct)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回结构 S 的元素 x 的值</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="built-in-functions">1.8. 内置的函数</h3>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表 1. Hive 支持以下内置的函数:</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">返回类型</th>
<th class="tableblock halign-left valign-top">函数名（注册名）</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">round(double a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a 的四舍五入整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">floor(double a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回不大于 a 的最大整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ceil(double a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回不小于 a 的最小整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rand(),rand(int seed)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回随机数，也可以指定随机种子</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">concat(string A, string B, &#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 字符串 B 接在 字符串 A 后字符串，这是一个字符串合并操作。比如 concat('foo', 'bar') 返回的结果就是 'foobar'。该函数接受任意数量的字符串参数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">substr(string A, int start)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回从字符串 A 的 索引位置 start 开始到结尾的子串。比如 substr('foobar', 4) 返回 'bar'。注意，索引是从1开始计算</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">substr(string A, int start, int length)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回从字符串 A 的索引位置 start 开始的，长度为 length 的字串。比如 substr('foobar', 4, 2) 的返回结果为 'ba'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">upper(string A)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回把字符串 A 的所有字符全部转为大写后的字符串。比如 upper('fOoBaR') 的结果为 'FOOBAR'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ucase(string A)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">等同于 upper 函数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lower(string A)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回把字符串 A 的所有字符全部转为小写后的字符串。比如 lower('fOoBaR') 的结果为 'foobar'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lcase(string A)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">等同于 lower 函数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">trim(string A )</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回去掉字符串 A 头尾所有空格字符后的字符串。比如 trim(' foobar    ') 的结果为 'foobar'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ltrim(string A)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回去掉字符串 A 左边开头的所有空格字符的字符串。比如 ltrim(' foobar   ') 的结果为 'foobar   '</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rtime(string A)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回去掉字符串 A 右边的所有空格字符的字符串。比如 ltrim(' foobar   ') 的结果为 ' foobar'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">regexp_replace(string A, string B ,string C)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把字符串 A 中所有符合正则表达式 B 的字符串全部用 C 来替代，如果 C 不存在，则用空替代（等同于删除）。比如 regexp_replace('foobar','oo|bar', 'B') 的返回结果为 'fBbB'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">size(Map&lt;K,V&gt;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 map 类型的元素数量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">size(Array&lt;T&gt;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 array 类型的元素数量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;type&gt; 值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cast(&lt;expr&gt; as &lt;type&gt;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将表达式 expr 的结果转为 &lt;type&gt;，比如 cast('1' as BIGINT) 将会返回数字1，而不是字符串1，类型为 BIGINT。如果转换失败，则返回为 null</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">from_unixtime(int unixtime)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把 unix 时间戳转为日期时间的字符串表达形式。比如 from_unixtime(1441521463) 返回的结果为 '2015-09-06 14:37:43'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">to_date(string timestamp)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字符串形式的时间的日期部分。比如 to_date('2012-12-24 11:23:45') 的返回结果为 '2012-12-24'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">year(string date)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回日期类型或字符串时间戳类型的年份部分。比如 year('2012-12-24 11:23:45') 的返回结果为 '2012'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">month(string date)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回日期类型或字符串时间戳类型的月部分。比如 month('2012-12-24 11:23:45) 的返回结果为 '12'，注意月份不会返回前缀0，比如 month('2012-01-01') 的返回结果为 1，而不是 '01'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">day(string date)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回日期类型或字符串时间戳类型的日部分。比如 year('2012-12-24 11:23:45') 的返回结果为 '24'，注意日不会返回前缀0，比如 day('2012-01-01') 的返回结果为 1，而不是 '01'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">get_json_object(string json_string, string path)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从一个 json 字符串中依据指定的 path 获取 json 对象，返回该 json 对象。如果输入的 json 串无效，则返回 null</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表 2. Hive 内置支持的聚合函数</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">返回类型</th>
<th class="tableblock halign-left valign-top">聚合函数名（注册名）</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">count(\*),count(expr),count(DISINCT expr[,expr])</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">count(*)&#8201;&#8212;&#8201;返回获取的行总数，包括哪些值为 NULL 的空行；count(expr)&#8201;&#8212;&#8201;返回符合 expr 表达式且不为 NULL 的所有行数；count(DISINCT expr[,expr]) 返回符合表达式 expr 且唯一的所有行数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sum(col)，sum(DISTINCT col)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sum(col)&#8201;&#8212;&#8201;返回所有符合条件的行记录中字段 col 的累加结果；sum(DISTINCT col)&#8201;&#8212;&#8201;返回所有符合条件的不同行记录的字段 col 的累加结果</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">avg(col), avg(DISINCT col)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字段 col 的算术平均结果</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">min(col)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字段 col 的最小值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">max(col)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字段 col 的最大值</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hive-getting-started">2. Hive 快速入门</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章给大家介绍 Hive 的基本使用，使得 Hive 的使用者能够快速了解和基本使用 Hive。</p>
</div>
<div class="sect2">
<h3 id="running-hive">2.1. 运行 Hive</h3>
<div class="paragraph">
<p>Hive 使用 Hadoop，因此：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>你必须配置了Hadoop，或</p>
</li>
<li>
<p>导出环境变量 <code>HADOOP_HOME=&lt;hadoop-install-dir&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你已经安装 TDP 产品，则只需要登录到任意一台服务器，然后切换到 <code>hive</code> 账号即可直接使用。
运行 Hive 有几种方式：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Hive Cli</p>
</li>
<li>
<p>HiveServer2/Beeline</p>
</li>
<li>
<p>HCatalog</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>下面分别介绍</p>
</div>
<div class="sect3">
<h4 id="running-hive-cli">2.1.1. 运行 Hive Cli</h4>
<div class="paragraph">
<p>这是最常见，也是最简单的使用 Hive 的方式，启用 Hive 服务的账号（一般是 <code>hive</code>)，执行运行下面的命令即可：</p>
</div>
<div class="paragraph">
<p><code>$HIVE_HOME/bin/hive</code></p>
</div>
</div>
<div class="sect3">
<h4 id="running-hiveserver2-and-beeline">2.1.2. 运行 HiveServer2 和 Beeline</h4>
<div class="paragraph">
<p>Beeline 连接到 HiveServer2 服务来和 Hive 进行交互，因此运行 Beeline 之前需要知道 HiveServer2 的服务器地址以及端口（默认为10000）。Beeline 是替代即将废弃的 HiveCli 的连接工具，它支持安全配置以及多用户连接。
其连接方式如下：</p>
</div>
<div class="paragraph">
<p><code>$HIVE_HOME/bin/beeline -u jdbc:hive2://$HS2_HOST:$HS2_PORT</code></p>
</div>
<div class="paragraph">
<p>上述 HS2_HOST 和 HS2_PORT 分别指 HiveServer2 的服务器地址和端口，假定你的 HiveServer2 在 <code>tdp2.tcloudata.com</code> 上，是使用默认端口，则实际连接方式为：</p>
</div>
<div class="paragraph">
<p><code>$HIVE_HOME/bin/beeline -u jdbc:hive2://tdp2.tcloudata.com:10000</code></p>
</div>
</div>
<div class="sect3">
<h4 id="running-hcatalog">2.1.3. 运行 HCatalog</h4>
<div class="paragraph">
<p>HCatalog 是 Hive 和其他组件(比如HBase)集成的桥梁接口，其他组件工作 HCatalog 接口可以直接访问 Hive 的数据而不关心 Hive 的配置。运行 HCatalog 的方式如下：</p>
</div>
<div class="paragraph">
<p><code>$HIVE_HOME/hcatalog/bin/hcat</code></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="runtime-configuration">2.2. 运行时配置</h3>
<div class="paragraph">
<p>Hive 查询实际上执行 map-reduce 过程，因此我们可以通过控制 Hadoop 的配置变量来控制查询的某些行为。
HiveCLI 和 Beeline 命令 <code>SET</code> 可以设置 Hadoop （或 Hive）的配置变量，比如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">beeline&gt; SET mapred.job.tracker=myhost.mycompany.com:50030;
beeline&gt; SET -v;</code></pre>
</div>
</div>
<div class="paragraph">
<p>后者显示当前的所有配置，如果没有 '-v' 选项，则仅显示和 Hadoop 配置不同的选项。</p>
</div>
</div>
<div class="sect2">
<h3 id="hive-mapred-local-mode">2.3. Hive MapReduce 以及本地模式</h3>
<div class="paragraph">
<p>对绝大部分查询而言，Hive 编译器均生成 map-reduce任务，这些任务然后提交给下面变量指定的 Map-Reduce 集群。
<code>mapred.job.tracker</code>。</p>
</div>
<div class="paragraph">
<p>通常一个 map-reduce 集群会有多个节点，Hadoop 也提供了一个不错的选项使得任务可以运行在本地节点上。这对于数据量不大的情况下是非常有帮助的&#8212;&#8203;这种情况下，本地运行因为不需要提交到集群然后分配任务，因此执行效率有明显的区别。
反过来说，对于大数据集而言，因为本地模式只有一个 reducer 进程，因此处理起来就会非常慢。</p>
</div>
<div class="paragraph">
<p>如果想运行本地模式，配置下面的选项即可。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; SET mapreduce.framework.name=local;</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外， <code>mapred.local.dir</code> 应该指向本地机器的某一个目录（比如 <em>/tmp/&lt;username&gt;/mapred/local</em>），否则的话，该方式将会产生异常。</p>
</div>
<div class="paragraph">
<p>另外，Hive 也支持自动运行在本地的方式，也就是 Hive 将依据执行的任务不同规模来确定该任务是否采取本地模式运行。
与此相关的选项包括 <code>hive.exec.mode.local.auto</code>，<code>hive.exec.mode.local.auto.inputbytes.max</code> 以及
<code>hive.exec.mode.local.auto.task.max</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; SET hive.exec.mode.local.auto=false;</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，这个特性默认是关闭的。如果启动，Hive 将会分析每一个 map-reduce 任务的大小，然后如果满足下面的阈值，则运行为本地模式。
* 任务的总输入大小比 <code>hive.exec.mode.local.auto.inputbytes.max</code> 的值小（默认是128MB)
* map 任务的总数量小于 <code>hive.exec.mode.local.auto.tasks.max</code> 的值小（默认是4）
* reduce 的总数量必须为0或1</p>
</div>
</div>
<div class="sect2">
<h3 id="hive-logging">2.4. Hive 日志</h3>
<div class="paragraph">
<p>Hive 使用 log4j 来记录日志。默认情况下，CLI 运行 Hive 时日志不会打印在终端。从 Hive 0.13.0 起，默认的日志级别是 <code>WARN</code>。
日志保存在 <em>/tmp/&lt;user.name&gt;/hive.log</em> 下。</p>
</div>
<div class="paragraph">
<p>如果想配置不同的目录，在 <code>hive-log4j.properties</code> 里配置 <code>hive.log.dir</code> 选项，注意配置的目录权限有粘滞位（<code>chmod 1777 &lt;dir&gt;</code>）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ini">hive.log.dir=&lt;other_location&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你希望日志打印在终端，增加下面两个参数</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell">bin/hive --hiveconf hive.root.logger=INFO,console //针对HiveCLI（即将废弃）
bin/hiveserver2 --hiveconf hive.root.logger=INFO,console</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，通过 'SET' 命令是无法改变日志属性的，因为该参数是在程序启动时就初始化好了的。</p>
</div>
<div class="paragraph">
<p>HiveServer2 操作日志从 Hive 0.14 开始引入，具体参考link:[hiveserver2-logging.adoc]</p>
</div>
<div class="paragraph">
<p>审计日志记录在 Hive metatsore 里，记录下每次的 metatsore API 调用。</p>
</div>
<div class="paragraph">
<p>为了获得 Hive 的性能指标，可以使用 PerfLogger 获得对应的日志，你需要设置为 'DEBUG' 模式，可以在 log4j 属性文件里配置下面的参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ini">log4j.logger.org.apache.hadoop.hive.ql.log.PerfLogger=DEBUG</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ddl-operations">2.5. DDL 操作</h3>
<div class="paragraph">
<p>详细的 Hive DDL 操作文档可以参看link:[hive-ddl.adoc]，这里简单描述。</p>
</div>
<div class="sect3">
<h4 id="create-hive-tables">2.5.1. 创建 Hive 表</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; CREATE TABLE pokes (foo INT, bar STRING);</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述命令创建名为 'pokes' 的表，该表有两个字段，其类型分别为整型和字符串型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; CREATE TABLE invites (foo INT, bar STRING) PARTITIONED BY (ds STRING);</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述命令创建一个包含两个字段的表 'invites'，同时还包含一个名为 'ds' 分区字段，分区字段是一个虚拟字段。它并不是数据本身的一部分，但它依据会依据规则把特定的数据载入到特定的分区表里。</p>
</div>
<div class="paragraph">
<p>默认情况下，表数据格式为文本文件，字段之间的分隔符为 '^A'(ctr-a)。</p>
</div>
</div>
<div class="sect3">
<h4 id="browsing-through-tables">2.5.2. 浏览表</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">  hive&gt; SHOW TABLES;</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述命令列出当前数据库下的所有表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; SHOW TABLES '.*s';</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述命令列出所有以 's' 结尾的表。后面实际上是一个 Java 风格的正则表达式，有关正则表达式的详细内容，可以参考<a href="http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html">Java正则表达式</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; DESCRIBE invites;</code></pre>
</div>
</div>
<div class="paragraph">
<p>显示表 'invites' 的字段信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="altering-and-dropping-tables">2.5.3. 修改和删除表</h4>
<div class="paragraph">
<p>表的名字的可以修改，表的字段可以增加和替代（但不能直接删除某一个字段），以下是一些表修改的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; ALTER TABLE events RENAME TO 3koobecaf;
hive&gt; ALTER TABLE pokes ADD COLUMNS (new_col INT);
hive&gt; ALTER TABLE invites ADD COLUMNS (new_col2 INT COMMENT 'a comment');
hive&gt; ALTER TABLE invites REPLACE COLUMNS (foo INT, bar STRING, baz INT COMMENT 'baz replaces new_col2');</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意上面例子中最后的 'REPLACE COLUMNS' 是替换了当前表的所有字段，但这仅仅是修改表的模式，其表的数据并没有改变，这点和传统关系型数据库有着本质的区别。</p>
</div>
<div class="paragraph">
<p>删除表的命令如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; DROP TABLE pokes;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="metadata-store">2.5.4. 元数据存储</h4>
<div class="paragraph">
<p>Hive 的元数据(Metastore) 可以保存在默认的嵌入数据库 Derby 里，也可以保存在所有支持 JPOX 的传统关系型数据库里，在生产环境下，我们推荐后者，以避免可能的性能问题。</p>
</div>
<div class="paragraph">
<p>使用哪中数据库以及保存在哪里有两个变量控制，分别是 <code>javax.jdo.option.ConnectURL</code> 和 <code>javax.jdo.option.ConnectDriverName</code>。参考 JDO（或JPOX）文档获得这方面更详细的内容。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dml-operations">2.6. DML 操作</h3>
<div class="paragraph">
<p>Hive 的 DML 操作的详细内容，可以参考 link:[hive-dml.adoc]，这里仅简单描述。</p>
</div>
<div class="paragraph">
<p>从文本文件载入数据到 Hive 表的命令类似如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; LOAD DATA LOCAL INPATH './examples/files/kv1.txt' OVERWRITE INTO TABLE pokes;</code></pre>
</div>
</div>
<div class="paragraph">
<p>加载的文件包含两列，列之间以 <code>ctrl-a</code> 分隔。 'LOCAl' 意味着该数据文件在本地文件系统，而不是在 HDFS 上。
关键字 'OVERWRITE' 表示已经存在当前表的数据在会被删除，如果没有这个关键字，则数据文件会追加到已存在的数据集中。</p>
</div>
<div class="paragraph">
<p>注意以下几点：
* 数据记在命令并不会校验数据的有效性
* 如果文件在 HDFS 上，载入操作会把文件移动到 Hive 控制的文件系统命名空间里。Hive 的根目录由配置文件 <code>hive-default.xml</code> 里的 <code>hive.metastore.warehouse.dir</code> 选项决定。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; LOAD DATA LOCAL INPATH './examples/files/kv2.txt' OVERWRITE INTO TABLE invites PARTITION (ds='2008-08-15');
hive&gt; LOAD DATA LOCAL INPATH './examples/files/kv3.txt' OVERWRITE INTO TABLE invites PARTITION (ds='2008-08-08');</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面两个 LOAD 语句把数据记在到表的不同分区里。表 'invites' 必须首先创建为按天分区的分区表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; LOAD DATA INPATH '/user/myname/kv2.txt' OVERWRITE INTO TABLE invites PARTITION (ds='2008-08-15');</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述命令是从 HDFS 文件（或目录）加载数据到表中。</p>
</div>
</div>
<div class="sect2">
<h3 id="sql-operations">2.7. SQL 操作</h3>
<div class="paragraph">
<p>有关 Hive 的查询详细内容，请参看link:[hive-select.adoc]，这里简单描述。
下面展示的查询例子，都可以在 <em>build/dist/examples/quries</em> 找得到。更多的一些查询例子可以在 Hive 的源代码 <em>ql/src/test/queries/postive</em> 中找到。</p>
</div>
<div class="sect3">
<h4 id="selects-and-filters">2.7.1. Select 和 Filters</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; SELECT a.foo FROM invites a WHERE a.ds='2008-08-15';</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述语句查询表 'invites' 中分区为 'ds=2008-08-15' 的所有 'foo' 字段数据，结果仅仅打印在终端，而不是保存。</p>
</div>
<div class="paragraph">
<p>注意，以下的所有例子， 'INSERT'（插入到 hive 表或本地目录或 HDFS 目录）都是可选的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; INSERT OVERWRITE DIRECTORY '/tmp/hdfs_out' SELECT a.* FROM invites a WHERE a.ds='2008-08-15';</code></pre>
</div>
</div>
<div class="paragraph">
<p>选择表分区为 'ds=2008-08-15' 的表 'invites' 的所有内容写入到 HDFS 目录 <em>/tmp/hdfs_out</em> 目录中，结果数据以文件的形式保存在上述目录中。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果使用 '.*' 的方式获取字段，那么分区字段也会包含在返回结果中；对于分区表，尽可能在 where 子句中出现选定特定分区的语句，防止数据量过大的情况
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; INSERT OVERWRITE LOCAL DIRECTORY '/tmp/local_out' SELECT a.* FROM pokes a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述语句表示从 pokes 表中选择所有的行写入到本地目录</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; INSERT OVERWRITE TABLE events SELECT a.* FROM profiles a;
hive&gt; INSERT OVERWRITE TABLE events SELECT a.* FROM profiles a WHERE a.key &lt; 100;
hive&gt; INSERT OVERWRITE LOCAL DIRECTORY '/tmp/reg_3' SELECT a.* FROM events a;
hive&gt; INSERT OVERWRITE DIRECTORY '/tmp/reg_4' select a.invites, a.pokes FROM profiles a;
hive&gt; INSERT OVERWRITE DIRECTORY '/tmp/reg_5' SELECT COUNT(*) FROM invites a WHERE a.ds='2008-08-15';
hive&gt; INSERT OVERWRITE DIRECTORY '/tmp/reg_5' SELECT a.foo, a.bar FROM invites a;
hive&gt; INSERT OVERWRITE LOCAL DIRECTORY '/tmp/sum' SELECT SUM(a.pc) FROM pc1 a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的语句展示了使用统计函数来获得特定的统计结果，然后将结果保存到文件中。</p>
</div>
</div>
<div class="sect3">
<h4 id="group-by">2.7.2. Group By</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; FROM invites a INSERT OVERWRITE TABLE events SELECT a.bar, count(*) WHERE a.foo &gt; 0 GROUP BY a.bar;
hive&gt; INSERT OVERWRITE TABLE events SELECT a.bar, count(*) FROM invites a WHERE a.foo &gt; 0 GROUP BY a.bar;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="join">2.7.3. Join</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; FROM pokes t1 JOIN invites t2 ON (t1.bar = t2.bar) INSERT OVERWRITE TABLE events SELECT t1.bar, t1.foo, t2.foo;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="multitable-insert">2.7.4. 多表插入</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">FROM src
INSERT OVERWRITE TABLE dest1 SELECT src.* WHERE src.key &lt; 100
INSERT OVERWRITE TABLE dest2 SELECT src.key, src.value WHERE src.key &gt;= 100 and src.key &lt; 200
INSERT OVERWRITE TABLE dest3 PARTITION(ds='2008-04-08', hr='12') SELECT src.key WHERE src.key &gt;= 200 and src.key &lt; 300
INSERT OVERWRITE LOCAL DIRECTORY '/tmp/dest4.out' SELECT src.value WHERE src.key &gt;= 300;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="streaming">2.7.5. Streaming</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; FROM invites a INSERT OVERWRITE TABLE events SELECT TRANSFORM(a.foo, a.bar) AS (oof, rab) USING '/bin/cat' WHERE a.ds &gt; '2008-08-09';</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="simple-example-use-cases">2.8. 简单用户使用案例</h3>
<div class="sect3">
<h4 id="movielens-user-ratings">2.8.1. MovieLens 用户评分使用案例</h4>
<div class="paragraph">
<p>首先，我们创建一个 tab 分隔的文本文件格式表</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">CREATE TABLE u_data (
  userid INT,
  movieid INT,
  rating INT,
  unixtime STRING)
ROW FORMAT DELIMITED
FIELDS TERMINATED BY '\t'
STORED AS TEXTFILE;</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，从<a href="http://grouplens.org/datasets/movielens/">GroupLens datasets</a> 下载 <strong>MovieLens 100k</strong> 数据：</p>
</div>
<div class="paragraph">
<p><code>wget <a href="http://files.grouplens.org/datasets/movielens/ml-100k.zip" class="bare">http://files.grouplens.org/datasets/movielens/ml-100k.zip</a></code></p>
</div>
<div class="paragraph">
<p>解压文件</p>
</div>
<div class="paragraph">
<p><code>unzip ml-100k.zip</code></p>
</div>
<div class="paragraph">
<p>然后，加载 'u.data' 到刚才创建表的里：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">LOAD DATA LOCAL INPATH '&lt;path&gt;/u.data' OVERWRITE INTO TABLE u_data;</code></pre>
</div>
</div>
<div class="paragraph">
<p>统计表的行数</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">SELECT COUNT(*) FROM u_data;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以做 'u_data' 表上做一些复杂的数据分析了：</p>
</div>
<div class="paragraph">
<p>创建 'weekday_mapper.py' 文件，内容如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="python">import sys
import datetime

for line in sys.stdin:
  line = line.strip()
  userid, movieid, rating, unixtime = line.split('\t')
  weekday = datetime.datetime.fromtimestamp(float(unixtime)).isoweekday()
  print '\t'.join([userid, movieid, rating, str(weekday)])</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用上述脚本</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">CREATE TABLE u_data_new (
  userid INT,
  movieid INT,
  rating INT,
  weekday INT)
ROW FORMAT DELIMITED
FIELDS TERMINATED BY '\t';

add FILE weekday_mapper.py;

INSERT OVERWRITE TABLE u_data_new
SELECT
  TRANSFORM (userid, movieid, rating, unixtime)
  USING 'python weekday_mapper.py'
  AS (userid, movieid, rating, weekday)
FROM u_data;

SELECT weekday, COUNT(*)
FROM u_data_new
GROUP BY weekday;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="apache-weblog-data">2.8.2. 保存 Apache 日志</h4>
<div class="paragraph">
<p>Apache 的日志格式是可以定制的，不过大部分情况下都是使用的默认格式。对于默认可以，我们可以使用下面的表来存储日志，并且对其进行解析。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">CREATE TABLE apachelog (
  host STRING,
  identity STRING,
  user STRING,
  time STRING,
  request STRING,
  status STRING,
  size STRING,
  referer STRING,
  agent STRING)
ROW FORMAT SERDE 'org.apache.hadoop.hive.serde2.RegexSerDe'
WITH SERDEPROPERTIES (
  "input.regex" = "([^]*) ([^]*) ([^]*) (-|\\[^\\]*\\]) ([^ \"]*|\"[^\"]*\") (-|[0-9]*) (-|[0-9]*)(?: ([^ \"]*|\".*\") ([^ \"]*|\".*\"))?"
)
STORED AS TEXTFILE;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hive_ddl">3. Hive DDL</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_概述">3.1. 概述</h3>
<div class="paragraph">
<p>HiveQL DDL 语句包括以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>CREATE DATABASE/SCHEMA, TABLE, VIEW, FUNCTION, INDEX</p>
</li>
<li>
<p>DROP DATABASE/SCHEMA, TABLE, VIEW, INDEX</p>
</li>
<li>
<p>TRUNCATE TABLE</p>
</li>
<li>
<p>ALTER DATABASE/SCHEMA, TABLE, VIEW</p>
</li>
<li>
<p>MSCK REPAIR TABLE (or ALTER TABLE RECOVER PARTITIONS)</p>
</li>
<li>
<p>SHOW DATABASES/SCHEMAS, TABLES, TBLPROPERTIES, PARTITIONS, FUNCTIONS, INDEX[ES], COLUMNS, CREATE TABLE</p>
</li>
<li>
<p>DESCRIBE DATABASE/SCHEMA, table_name, view_name</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>PARTITIONS 语句用于建表语句中，除了 'SHOW PARTITIONS' 之外。</p>
</div>
</div>
<div class="sect2">
<h3 id="_关键字">3.2. 关键字</h3>
<div class="listingblock">
<div class="title">关键字</div>
<div class="content">
<pre>ADD,ADMIN,AFTER,ALL,ALTER,ANALYZE,AND,ARCHIVE,ARRAY,AS,ASC,AUTHORIZATION,BEFORE,BETWEEN,
BIGINT,BINARY,BOOLEAN,BOTH,BUCKET,BUCKETS,BY,CASCADE,CASE,CAST,CHANGE,CHAR,CLUSTER,
CLUSTERED,CLUSTERSTATUS,COLLECTION,COLUMN,COLUMNS,COMMENT,COMPACT,COMPACTIONS,COMPUTE,
CONCATENATE,CONF,CONTINUE,CREATE,CROSS,CUBE,CURRENT,CURRENT_DATE,CURRENT_TIMESTAMP,CURSOR,
DATA,DATABASE,DATABASES,DATE,DATETIME,DAY,DBPROPERTIES,DECIMAL,DEFERRED,DEFINED,DELETE,
DELIMITED,DEPENDENCY,DESC,DESCRIBE,DIRECTORIES,DIRECTORY,DISABLE,DISTINCT,DISTRIBUTE,
DOUBLE,DROP,ELEM_TYPE,ELSE,ENABLE,END,ESCAPED,EXCHANGE,EXCLUSIVE,EXISTS,EXPLAIN,EXPORT,
EXTENDED,EXTERNAL,FALSE,FETCH,FIELDS,FILE,FILEFORMAT,FIRST,FLOAT,FOLLOWING,FOR,FORMAT,
FORMATTED,FROM,FULL,FUNCTION,FUNCTIONS,GRANT,GROUP,GROUPING,HAVING,HOLD_DDLTIME,HOUR,
IDXPROPERTIES,IF,IGNORE,IMPORT,IN,INDEX,INDEXES,INNER,INPATH,INPUTDRIVER,INPUTFORMAT,
INSERT,INT,INTERSECT,INTERVAL,INTO,IS,ITEMS,JAR,JOIN,KEYS,KEY_TYPE,LATERAL,LEFT,LESS,
LIKE,LIMIT,LINES,LOAD,LOCAL,LOCATION,LOCK,LOCKS,LOGICAL,LONG,MACRO,MAP,MAPJOIN,
MATERIALIZED,MINUS,MINUTE,MONTH,MORE,MSCK,NONE,NOSCAN,NOT,NO_DROP,NULL,OF,OFFLINE,ON,
OPTION,OR,ORDER,OUT,OUTER,OUTPUTDRIVER,OUTPUTFORMAT,OVER,OVERWRITE,OWNER,PARTIALSCAN,
PARTITION,PARTITIONED,PARTITIONS,PERCENT,PLUS,PRECEDING,PRECISION (Hive 2.2.0+),
PRESERVE,PRETTY,PRINCIPALS,PROCEDURE,PROTECTION,PURGE,RANGE,READ,READONLY,READS,REBUILD,
RECORDREADER,RECORDWRITER,REDUCE,REGEXP,RELOAD,RENAME,REPAIR,REPLACE,RESTRICT,REVOKE,
REWRITE,RIGHT,RLIKE,ROLE,ROLES,ROLLUP,ROW,ROWS,SCHEMA,SCHEMAS,SECOND,SELECT,SEMI,SERDE,
SERDEPROPERTIES,SERVER,SET,SETS,SHARED,SHOW,SHOW_DATABASE,SKEWED,SMALLINT,SORT,SORTED,
SSL,STATISTICS,STORED,STREAMTABLE,STRING,STRUCT,TABLE,TABLES,TABLESAMPLE,TBLPROPERTIES,
TEMPORARY,TERMINATED,THEN,TIMESTAMP,TINYINT,TO,TOUCH,TRANSACTIONS,TRANSFORM,TRIGGER,TRUE,
TRUNCATE,UNARCHIVE,UNBOUNDED,UNDO,UNION,UNIONTYPE,UNIQUEJOIN,UNLOCK,UNSET,UNSIGNED,UPDATE,
URI,USE,USER,USING,UTC,UTCTIMESTAMP,VALUES,VALUE_TYPE,VARCHAR,VIEW,WHEN,WHERE,WHILE,
WINDOW,WITH,YEAR</pre>
</div>
</div>
<div class="listingblock">
<div class="title">非保留关键字</div>
<div class="content">
<pre>ADD,ADMIN,AFTER,ANALYZE,ARCHIVE,ASC,BEFORE,BUCKET,BUCKETS,CASCADE,CHANGE,CLUSTER,
CLUSTERED,CLUSTERSTATUS,COLLECTION,COLUMNS,COMMENT,COMPACT,COMPACTIONS,COMPUTE,
CONCATENATE,CONTINUE,DATA,DATABASES,DATETIME,DAY,DBPROPERTIES,DEFERRED,DEFINED,
DELIMITED,DEPENDENCY,DESC,DIRECTORIES,DIRECTORY,DISABLE,DISTRIBUTE,ELEM_TYPE,ENABLE,
ESCAPED,EXCLUSIVE,EXPLAIN,EXPORT,FIELDS,FILE,FILEFORMAT,FIRST,FORMAT,FORMATTED,
FUNCTIONS,HOLD_DDLTIME,HOUR,IDXPROPERTIES,IGNORE,INDEX,INDEXES,INPATH,INPUTDRIVER,
INPUTFORMAT,ITEMS,JAR,KEYS,KEY_TYPE,LIMIT,LINES,LOAD,LOCATION,LOCK,LOCKS,LOGICAL,LONG,
MAPJOIN,MATERIALIZED,MINUS,MINUTE,MONTH,MSCK,NOSCAN,NO_DROP,OFFLINE,OPTION,OUTPUTDRIVER,
OUTPUTFORMAT,OVERWRITE,OWNER,PARTITIONED,PARTITIONS,PLUS,PRETTY,PRINCIPALS,PROTECTION,
PURGE,READ,READONLY,REBUILD,RECORDREADER,RECORDWRITER,REGEXP (Hive 0.x.x and 1.x.x),
RELOAD,RENAME,REPAIR,REPLACE,RESTRICT,REWRITE,RLIKE (Hive 0.x.x and 1.x.x),ROLE,ROLES,
SCHEMA,SCHEMAS,SECOND,SEMI,SERDE,SERDEPROPERTIES,SERVER,SETS,SHARED,SHOW,SHOW_DATABASE,
SKEWED,SORT,SORTED,SSL,STATISTICS,STORED,STREAMTABLE,STRING,STRUCT,TABLES,TBLPROPERTIES,
TEMPORARY,TERMINATED,TINYINT,TOUCH,TRANSACTIONS,UNARCHIVE,UNDO,UNIONTYPE,UNLOCK,UNSET,
UNSIGNED,URI,USE,UTC,UTCTIMESTAMP,VALUE_TYPE,VIEW,WHILE,YEAR</pre>
</div>
</div>
<div class="listingblock">
<div class="title">保留关键字</div>
<div class="content">
<pre>ALL,ALTER,AND,ARRAY,AS,AUTHORIZATION,BETWEEN,BIGINT,BINARY,BOOLEAN,BOTH,BY,CASE,CAST,
CHAR,COLUMN,CONF,CREATE,CROSS,CUBE,CURRENT,CURRENT_DATE,CURRENT_TIMESTAMP,CURSOR,
DATABASE,DATE,DECIMAL,DELETE,DESCRIBE,DISTINCT,DOUBLE,DROP,ELSE,END,EXCHANGE,EXISTS,
EXTENDED,EXTERNAL,FALSE,FETCH,FLOAT,FOLLOWING,FOR,FROM,FULL,FUNCTION,GRANT,GROUP,
GROUPING,HAVING,IF,IMPORT,IN,INNER,INSERT,INT,INTERSECT,INTERVAL,INTO,IS,JOIN,LATERAL,
LEFT,LESS,LIKE,LOCAL,MACRO,MAP,MORE,NONE,NOT,NULL,OF,ON,OR,ORDER,OUT,OUTER,OVER,
PARTIALSCAN,PARTITION,PERCENT,PRECEDING,PRESERVE,PROCEDURE,RANGE,READS,REDUCE,
REGEXP (Hive 2.0.0 onward),REVOKE,RIGHT,RLIKE (Hive 2.0.0 onward),ROLLUP,ROW,ROWS,
SELECT,SET,SMALLINT,TABLE,TABLESAMPLE,THEN,TIMESTAMP,TO,TRANSFORM,TRIGGER,TRUE,
TRUNCATE,UNBOUNDED,UNION,UNIQUEJOIN,UPDATE,USER,USING,VALUES,VARCHAR,WHEN,WHERE,
WINDOW,WITH</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数据库定义">3.3. 数据库定义</h3>
<div class="listingblock">
<div class="title">创建数据库</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">CREATE (DATABASE|SCHEMA) [IF NOT EXISTS] database_name
  [COMMENT database_comment]
  [LOCATION hdfs_path]
  [WITH DBPROPERTIES (property_name=property_value, ...)];</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 DATABASE 和 SCHEMA 是等价的。</p>
</div>
<div class="listingblock">
<div class="title">删除数据库</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">DROP (DATABASE|SCHEMA) [IF EXISTS] database_name [RESTRICT|CASCADE];</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，删除数据库采取 RESTRICT 模式，也就是当该数据库下还有表时，删除数据库将会失败。如果确定要删除含有表的数据库，使用 <code>DROP DATABASE &#8230;&#8203; CASCADE</code> 语句。</p>
</div>
<div class="listingblock">
<div class="title">修改数据库</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ALTER (DATABASE|SCHEMA) database_name SET DBPROPERTIES (property_name=property_value, ...);

ALTER (DATABASE|SCHEMA) database_name SET OWNER [USER|ROLE] user_or_role;</code></pre>
</div>
</div>
<div class="paragraph">
<p>目前针对数据库的元数据修改仅限上面两种。</p>
</div>
</div>
<div class="sect2">
<h3 id="_表定义">3.4. 表定义</h3>
<div class="sect3">
<h4 id="_创建表">3.4.1. 创建表</h4>
<div class="paragraph">
<p>表的创建语句如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name
  [(col_name data_type [COMMENT col_comment], ...)]
  [COMMENT table_comment]
  [PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)]
  [CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]
  [SKEWED BY (col_name, col_name, ...)
     ON ((col_value, col_value, ...), (col_value, col_value, ...), ...)
     [STORED AS DIRECTORIES]
  [
   [ROW FORMAT row_format]
   [STORED AS file_format]
     | STORED BY 'storage.handler.class.name' [WITH SERDEPROPERTIES (...)]
  ]
  [LOCATION hdfs_path]
  [TBLPROPERTIES (property_name=property_value, ...)]
  [AS select_statement];

CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name
  LIKE existing_table_or_view_name
  [LOCATION hdfs_path];

data_type
  : primitive_type
  | array_type
  | map_type
  | struct_type
  | union_type

primitive_type
  : TINYINT
  | SMALLINT
  | INT
  | BIGINT
  | BOOLEAN
  | FLOAT
  | DOUBLE
  | DOUBLE PRECISION
  | STRING
  | BINARY
  | TIMESTAMP
  | DECIMAL
  | DECIMAL(precision, scale)
  | DATE
  | VARCHAR
  | CHAR

array_type
  : ARRAY &lt; data_type &gt;

map_type
  : MAP &lt; primitive_type, data_type &gt;

struct_type
  : STRUCT &lt; col_name : data_type [COMMENT col_comment], ...&gt;

union_type
   : UNIONTYPE &lt; data_type, data_type, ... &gt;

row_format
  : DELIMITED [FIELDS TERMINATED BY char [ESCAPED BY char]] [COLLECTION ITEMS TERMINATED BY char]
        [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char]
        [NULL DEFINED AS char]
  | SERDE serde_name [WITH SERDEPROPERTIES (property_name=property_value, property_name=property_value, ...)]

file_format:
  : SEQUENCEFILE
  | TEXTFILE
  | RCFILE
  | ORC
  | PARQUET
  | AVRO
  | INPUTFORMAT input_format_classname OUTPUTFORMAT output_format_classname</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>CREATE TABLE</code> 创建一个给定名字的数据库表。如果表名或试图名已经存在，则会抛出异常。可以使用 <code>IF NOT EXISTS</code> 语句来掉过这种错误。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>表名和字段名不区分大小写，但是 SerDe 以及属性名却分大小写</p>
</li>
<li>
<p>表和字段注释为字符串（单引号）</p>
</li>
<li>
<p><code>TBLPROPERTIES</code> 子语句允许你使用key-value形式来自定义表的元数据信息。同时也预定义了一些表属性，比如 <code>last_modified_user</code>, <code>last_modified_time</code> 这些属性
由 Hive 自动添加和管理，其他预定义的属性有：</p>
<div class="ulist">
<ul>
<li>
<p>TBLPROPERTIES ("comment"="table_comment")</p>
</li>
<li>
<p>TBLPROPERTIES ("hbase.table.name"="table_name") – see HBase Integration.</p>
</li>
<li>
<p>TBLPROPERTIES ("immutable"="true") or ("immutable"="false") in release 0.13.0+ (HIVE-6406) – see Inserting Data into Hive Tables from Queries.</p>
</li>
<li>
<p>TBLPROPERTIES ("orc.compress"="ZLIB") or ("orc.compress"="SNAPPY") or ("orc.compress"="NONE") and other ORC properties – see ORC Files.</p>
</li>
<li>
<p>TBLPROPERTIES ("transactional"="true") or ("transactional"="false") in release 0.14.0+, the default is "false" – see Hive Transactions.</p>
</li>
<li>
<p>TBLPROPERTIES ("NO_AUTO_COMPACTION"="true") or ("NO_AUTO_COMPACTION"="false"), the default is "false" – see Hive Transactions.</p>
</li>
<li>
<p>TBLPROPERTIES ("compactor.mapreduce.map.memory.mb"="mapper_memory") – see Hive Transactions.</p>
</li>
<li>
<p>TBLPROPERTIES ("compactorthreshold.hive.compactor.delta.num.threshold"="threshold_num") – see Hive Transactions.</p>
</li>
<li>
<p>TBLPROPERTIES ("compactorthreshold.hive.compactor.delta.pct.threshold"="threshold_pct") – see Hive Transactions.</p>
</li>
<li>
<p>TBLPROPERTIES ("auto.purge"="true") or ("auto.purge"="false") in release 1.2.0+ (HIVE-9118) – see Drop Table and Drop Partitions.</p>
</li>
<li>
<p>TBLPROPERTIES ("EXTERNAL"="TRUE") in release 0.6.0+ (HIVE-1329) – Change a managed table to an external table and vice versa for "FALSE".</p>
</li>
</ul>
</div>
</li>
<li>
<p>如果要指定表名所在的数据库，一种方式是先用 <code>USE &lt;DATABASE&gt;</code> 语句切换到数据库，然后使用 <code>CREATE</code> 语句创建表。或者直接使用 <code>CREATE database_name.table_name</code> 的方式。默认情况下，当前数据库为 <em>default</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">Row Format,Storage Format,and SerDe</div>
<p>我们可以使用自定义的 SerDe 或者原生的 SerDe 创建表。如果没有指定 ROW FORMAT 或者指定了 ROW FORMAT DELIMITED，则使用原生的 SerDe。我们可以使用 DELIMITED 子语句来获取带分隔的文件，使用 'ESCAPED BY' 来指定转义字符(比如 ESCAPED BY '\t')。可以使用 'NULL DEFINED' 语句自定义 NULL 格式（默认是 '\N'）。使用 'SERDE' 子语句可以创建自定义的 SerDe。</p>
</div>
<div class="paragraph">
<p>如果希望数据已纯文本形式保存，使用 STORED AS TEXTFILE。 TEXTFILE 是默认文件格式，除非配置项 <code>hive.default.fileformat</code> 的参数有不同设置。</p>
</div>
<div class="paragraph">
<p>如果希望数据压缩存放，可以使用 STORED AS SEQUENCEFILE。</p>
</div>
<div class="paragraph">
<p>如果希望数据以 ORC 文件格式存放，使用 STORED AS ORC。</p>
</div>
<div class="paragraph">
<p>针对需要使用正规表达式来分隔数据字段的，可以使用 ROW FORMAT SERDE。我们在<a href="hive-started.adoc">Hive快速入门</a>的最后演示了这种使用方法。</p>
</div>
<div class="paragraph">
<p>在 file_format 里使用 INPUTFORMAT 和  OUTPUTFORMAT 分别指定 InputFormat 和 OutputFormat 的类。比如，<code>org.apache.hadoop.hive.contrib.fileformat.base64.Base64TextInputFormat</code>。如果想使用 LZO 压缩的话，使用 'INPUTFORMAT "com.hadoop.mapred.DeprecatedLzoTextInputFormat" OUTPUTFORMAT "org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat"'</p>
</div>
<div class="paragraph">
<p>如果想使用 Parquet 列存储的话，使用 STORED AS PARQUET</p>
</div>
<div class="paragraph">
<p>使用 STORED AS AVRO 保存为 Avro 格式文件</p>
</div>
<div class="paragraph">
<p>如果要修改 SerDe 或者 TBLPROPERTIES 属性，使用 ALTER TABLE 语句。</p>
</div>
<div class="paragraph">
<div class="title">分区表</div>
<p>分区表通过 PARTITIONED BY 子语句创建。一个表可以有一个或多个分区字段，在物理数据存储上，是按照分区字段进行目录分层的。分区表同时可以使用 CLUSTER BY 子语句进行分桶。这种方式某些特定的查询可以提升效率。</p>
</div>
<div class="paragraph">
<p>如果创建分区时遇到这样的错误：“FAILED: Error in semantic analysis: Column repeated in partitioning columns,” 这意味着你要指定的分区字段已经包含在表定义里面了。分区表字段是一个虚假字段，它并不包含在表定义自身里，但是该字段不能和表定义里的字段重名。</p>
</div>
<div class="paragraph">
<p>比如，假设你的原始非分区表定义如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">id  int,
sdate date,
name varchar</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，你想按照日期来进行分区，那么 "sdate" 字段就需要从表定义从移出作为分区字段，如果你想保留数据格式不变，那么可以用别的字段的名字来代替现在的 "sdate" 字段名字。比如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">create table table_name (
  id                int,
  dtDontQuery       string,
  name              string
)
partitioned by (date string)</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，你可以使用 <code>where date = '&#8230;&#8203;.'</code> 来进行查询，表的第二个字段 dtDontQuery 会保留原始数据。</p>
</div>
<div class="paragraph">
<p>下面是创建一个分区表的另外一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">CREATE TABLE page_view(viewTime INT, userid BIGINT,
     page_url STRING, referrer_url STRING,
     ip STRING COMMENT 'IP Address of the User')
 COMMENT 'This is the page view table'
 PARTITIONED BY(dt STRING, country STRING)
 STORED AS SEQUENCEFILE;</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的语句创建了名为 page_view 的表，包含了 viewTime, userid, page_url, referrer_url, ip 5个字段（ip 字段还包含注释）。该表用了两个字段做分区，同时使用SEQUENCE存储格式。大数据文件的字段分隔符号为 <code>ctrl-A</code>，记录分隔为换行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">CREATE TABLE page_view(viewTime INT, userid BIGINT,
     page_url STRING, referrer_url STRING,
     ip STRING COMMENT 'IP Address of the User')
 COMMENT 'This is the page view table'
 PARTITIONED BY(dt STRING, country STRING)
 ROW FORMAT DELIMITED
   FIELDS TERMINATED BY '\001'
STORED AS SEQUENCEFILE;</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的语句创建的表和之前创建的 page_view 等价。</p>
</div>
<div class="paragraph">
<div class="title">外部表</div>
<p>EXTERNAL 关键字允许我们使用 LOCATION 来指定表的数据文件位置，而不是用默认的位置。比如我们已经有了数据，需要在该数据上创建一个对应的表，就可以使用这种方式。
当我们删除一个外部表时，表的数据<strong>不会</strong>被删除，这是它和和非外部表（管理表）的最大区别。</p>
</div>
<div class="paragraph">
<p>一个外部表的数据位置可以指向HDFS的任何目录。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">CREATE EXTERNAL TABLE page_view(viewTime INT, userid BIGINT,
     page_url STRING, referrer_url STRING,
     ip STRING COMMENT 'IP Address of the User',
     country STRING COMMENT 'country of origination')
 COMMENT 'This is the staging page view table'
 ROW FORMAT DELIMITED FIELDS TERMINATED BY '\054'
 STORED AS TEXTFILE
 LOCATION '&lt;hdfs_location&gt;';</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述语句依然是创建 page_view 表，与之前的创表语句不同的是，这里我们指定了数据文件的存放位置，不是默认使用 ' hive.metastore.warehouse.dir' 里所定义的路径。</p>
</div>
<div class="paragraph">
<div class="title">Create Table As Select(CTAS)</div>
<p>表也可以通过查询语句的方式来创建。这种创建方式是原子的，这意味着表在创建成功之前是看不到看表的。</p>
</div>
<div class="paragraph">
<p>CTAS分为两部分，SELECT部分支持HiveQL的所有SELECT语句。而CREATE部分允许定义表的一些其他属性，比如SerDe。</p>
</div>
<div class="paragraph">
<p>CTAS 有以下限制：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建的表不能有分区</p>
</li>
<li>
<p>创建的表不能是外部表</p>
</li>
<li>
<p>创建的表不能有桶定义</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">CREATE TABLE new_key_value_store
   ROW FORMAT SERDE "org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe"
   STORED AS RCFile
   AS
SELECT (key % 1024) new_key, concat(key, value) key_value_pair
FROM key_value_store
SORT BY new_key, key_value_pair;</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述语句创建名为 new_key_value_store 的表，表的字段包含 new_key, key_value_pair 两个。如果在 SELECT 语句中不指定字段别名，则表的字段会自动命名为 _col0, _col1。</p>
</div>
<div class="paragraph">
<div class="title">Create Table Like</div>
<p>Like 允许你拷贝一个已经存在的表的定义（但不拷贝数据），和 CTAS 的不同是，下面的创建语句是完全匹配源表的。而不仅仅是表名。新创建的表不包含数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">CREATE TABLE empty_key_value_store
LIKE key_value_store;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Bucketed Sorted Tables</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">CREATE TABLE page_view(viewTime INT, userid BIGINT,
     page_url STRING, referrer_url STRING,
     ip STRING COMMENT 'IP Address of the User')
 COMMENT 'This is the page view table'
 PARTITIONED BY(dt STRING, country STRING)
 CLUSTERED BY(userid) SORTED BY(viewTime) INTO 32 BUCKETS
 ROW FORMAT DELIMITED
   FIELDS TERMINATED BY '\001'
   COLLECTION ITEMS TERMINATED BY '\002'
   MAP KEYS TERMINATED BY '\003'
 STORED AS SEQUENCEFILE;</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>上面的语句，创建名为 page_view 的表，表按 userid 分桶，每个桶里的数据按照 viewTime 的升序存储。这种方式查询 userid 和 viewTime 时效率会很高。 MAP KEYS 和 COLLECTION ITEMS 关键字是定义字段里列表结构(list)和映射结构(map)的成员存储分隔符。</pre>
</div>
</div>
<div class="paragraph">
<p>CLUSTERED BY 和 SORTED BY 创建语句并不影响数据是如何插入到表里的，它仅仅影响数据如何读。
这意味着当我们插入数据时要仔细考虑，要指定和桶数量一致的reducer的数量，查询时使用 CLUSTERED BY 和 SORTED BY 语句。</p>
</div>
</div>
<div class="sect3">
<h4 id="_删除表">3.4.2. 删除表</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">DROP TABLE [IF EXISTS] table_name [PURGE];</code></pre>
</div>
</div>
<div class="paragraph">
<p>DROP TABLE 删除表的表定义以及表数据。表的数据实际上移到 <em>.Trash/Current</em> 目录下（如果配置了 Trash 的话，PURGE 不支持该功能）。而表定义则彻底丢失。</p>
</div>
<div class="paragraph">
<p>当删除一个外部表时（EXTERNAL）,仅仅删除表的表定义，数据并不会删除。</p>
</div>
<div class="paragraph">
<p>当删除一个被视图(view)引用的表时，并不会给出警告（视图定义存在，但已无意义，需要人工删除或者重新创建）</p>
</div>
<div class="paragraph">
<p>如果用户误删除了一个表，可以在用户的 <em>.Trash/Current</em> 目录下，找到表数据，你只需重新创建表定义，然后把数据移动到表的数据目录即可恢复表。</p>
</div>
<div class="paragraph">
<p>如果删除表时指定了 PURGE 关键字，则表的数据并不会进入 <em>.Trash/Current</em> 目录，而是直接删除。因此需要谨慎使用该关键字。</p>
</div>
</div>
<div class="sect3">
<h4 id="_清空表">3.4.3. 清空表</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql"> TRUNCATE TABLE table_name [PARTITION partition_spec];

partition_spec:
  : (partition_column = partition_col_value, partition_column = partition_col_value, ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>从一个表或者分区了删除所有的记录。如果开启了 Trash 模式，则这些数据会移动到 Trash 里。对外部表执行 TRUNCATE 操作会抛出异常。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_修改表_分区_字段">3.5. 修改表/分区/字段</h3>
<div class="sect3">
<h4 id="_修改表">3.5.1. 修改表</h4>
<div class="listingblock">
<div class="title">重命名</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ALTER TABLE table_name RENAME TO new_table_name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该语句改修表的名字为新的表名</p>
</div>
<div class="listingblock">
<div class="title">修改表属性</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ALTER TABLE table_name SET TBLPROPERTIES table_properties;

table_properties:
  : (property_name = property_value, property_name = property_value, ... )</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述语句可以修改、增加一个表的元数据信息。当前 last_modified_user, last_modified_time 两个属性不能自定义，由 Hive 来自动管理。用户可以自行定义元数据信息。
这些信息可以通过 DESCRIBE EXTENDED TABLE 来查看。</p>
</div>
<div class="listingblock">
<div class="title">修改表注释</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ALTER TABLE table_name SET TBLPROPERTIES ('comment' = new_comment);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">增加SerDe属性</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ALTER TABLE table_name [PARTITION partition_spec] SET SERDE serde_class_name [WITH SERDEPROPERTIES serde_properties];

ALTER TABLE table_name [PARTITION partition_spec] SET SERDEPROPERTIES serde_properties;

serde_properties:
  : (property_name = property_value, property_name = property_value, ... )</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些数据可以修改表的SerDe或用户定义的针对SerDe对象的元数据。</p>
</div>
<div class="paragraph">
<p>这些 SerDe 信息在 Hive 初始化序列器和反序列器是传递进来。因此用户可以存储任意自定义的SerDe需要的信息。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p><em>property_name</em> 和 <em>property_value</em> 都需要引号。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ALTER TABLE table_name SET SERDEPROPERTIES ('field.delim' = ',');</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">修改表存储属性</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ALTER TABLE table_name CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name, ...)]
  INTO num_buckets BUCKETS;</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述语句修改表的物理存储属性。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>这些命令仅修改 Hive 的元数据。并不是重新组织和重新格式化已经存在的数据。用户要确保实际的数据层结构和元数据定义的结构相匹配。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_修改分区">3.5.2. 修改分区</h4>
<div class="paragraph">
<p>ALTER TABLE 语句的 PARTITION 子语句可以增加、重命名、交换（移动）、删除、归档分区。</p>
</div>
<div class="listingblock">
<div class="title">增加分区</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ALTER TABLE table_name ADD [IF NOT EXISTS] PARTITION partition_spec
  [LOCATION 'location1'] partition_spec [LOCATION 'location2'] ...;

partition_spec:
  : (partition_column = partition_col_value, partition_column = partition_col_value, ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>ALTER TABLE ADD PARTITION 语句可以在一个表上增加一个分区，如果分区值时字符串，需要用引号。分区的物理位置(location)不是包含了数据文件的目录。（ADD PARTITION 只是改变了表的元数据，并没有加载数据。如果该分区的物理位置不存在数据，那么任何查询都会返回空）。如果分区已经存在，则抛出异常。</p>
</div>
<div class="paragraph">
<p>Hive 允许在一个单个 ALTER 语句里同时增加多个分区，比如下面这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ALTER TABLE page_view ADD PARTITION (dt='2015-08-08', country='us') location '/path/to/us/part150808'
                          PARTITION (dt='2015-08-09', country='us') location '/path/to/us/part150809';</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">重命名分区</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ALTER TABLE table_name PARTITION partition_spec RENAME TO PARTITION partition_spec;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该语句用来修改分区字段的值，一个可以用到的地方是比如一个分区表随着时间的推进，对分区的字段有了一个一个标准，用该语句可以把原来老的分区进行标准化。</p>
</div>
<div class="paragraph">
<div class="title">交换分区</div>
<p>分区可以在量表之间交换（移动）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ALTER TABLE table_name_1 EXCHANGE PARTITION (partition_spec) WITH TABLE table_name_2;
-- multiple partitions
ALTER TABLE table_name_1 EXCHANGE PARTITION (partition_spec, partition_spec2, ...) WITH TABLE table_name_2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的语句允许你把一个表的分区数据移动到另外一个有着相同表模式的表中。</p>
</div>
<div class="paragraph">
<div class="title">恢复分区</div>
<p>Hive 在它的元数据库里没一个表存储了分区信息。如果一个表的新分区是通过增加把数据增加到 HDFS 的（比如 hadoop dfs -put 来上传数据），那么元数据并不知道有这样的一个分区存在，除非你使用 ALTER TABLE <em>table_name</em> ADD PARTITION 命令来显式的增加分区。</p>
</div>
<div class="paragraph">
<p>不过，我们也可以通过运行带修复方式的元数据库检查命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">MSCK REPAIR TABLE table_name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>来告诉元数据库把那些分区已经物理存在，但还没有记录在元数据库中的分区全部增加进来。</p>
</div>
<div class="paragraph">
<p>如果存在大量的没有记录在元数据库中的分区，那么尽可能使用批量模式来运行上述命令，以防止出现 OOM 的情况。可以通过配置 <em>hive.msck.repair.batch.size</em> 参数来实现这个功能。该参数默认值是0，意味着一次性扫描扫描所有的分区。</p>
</div>
<div class="paragraph">
<p>如果分区的数据目录存在不允许的字符，则上述命令会抛出异常。可以配置 <em>hive.msck.path.validation</em> 参数来修改默认行为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>skip 跳过这些目录</p>
</li>
<li>
<p>ignore 无论如何都创建该分区，但是不保证能正常使用</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">删除分区</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ALTER TABLE table_name DROP [IF EXISTS] PARTITION partition_spec[, PARTITION partition_spec, ...]
  [IGNORE PROTECTION] [PURGE];</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的语句会删除表的一个或多个分区。它将从 Hive 元数据库中删除分区信息以及把 HDFS 上数据目录移动到 <em>.Trash/Current</em> 目录（如果配置了 Trash 功能），如果指定到了 PURGE 参数，则直接删除数据文件。</p>
</div>
<div class="paragraph">
<p>如果删除的分区不存在，则抛出异常。</p>
</div>
<div class="listingblock">
<div class="title">归档/解档分区</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ALTER TABLE table_name ARCHIVE PARTITION partition_spec;
ALTER TABLE table_name UNARCHIVE PARTITION partition_spec;</code></pre>
</div>
</div>
<div class="paragraph">
<p>归档是把一个分区的下的所有文件打包成一个 Hadoop 归档结构(HAR)。值得注意的是，归档模式并不做压缩，因此并不是减少文件的大小，但它减少的文件的数量。可以类比本地文件系统的 tar 的非压缩使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_修改字段">3.5.3. 修改字段</h4>
<div class="listingblock">
<div class="title">更改字段名/类型/位置/注释</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ALTER TABLE table_name [PARTITION partition_spec] CHANGE [COLUMN] col_old_name col_new_name column_type
  [COMMENT col_comment] [FIRST|AFTER column_name] [CASCADE|RESTRICT];</code></pre>
</div>
</div>
<div class="paragraph">
<p>该语句可以改变一个字段的名字、数据类型、注释或位置或者他们的任意组合。该语句同样也对分区有效。</p>
</div>
<div class="paragraph">
<p>下面一些使用的例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">CREATE TABLE test_change (a int, b int, c int);

// First change column a s name to a1.
ALTER TABLE test_change CHANGE a a1 INT;

// Next change column a1 name to a2, its data type to string, and put it after column b.
ALTER TABLE test_change CHANGE a1 a2 STRING AFTER b;
// The new table structure is:  b int, a2 string, c int.

// Then change column c  name to c1, and put it as the first column.
ALTER TABLE test_change CHANGE c c1 INT FIRST;
// The new table structure is:  c1 int, b int, a2 string.

// Add a comment to column a1
ALTER TABLE test_change CHANGE a1 a1 INT COMMENT 'this is column a1';</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">增加/替换字段</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ALTER TABLE table_name
  [PARTITION partition_spec]
  ADD|REPLACE COLUMNS (col_name data_type [COMMENT col_comment], ...)
  [CASCADE|RESTRICT]</code></pre>
</div>
</div>
<div class="paragraph">
<p>ADD COLUMNS 子句增加一个字段到表中，字段位于所有表的最后，但是在分区之前的前面。</p>
</div>
<div class="paragraph">
<p>REPLACE COLUMNS 删除表中所有的字段然后重新增加指定的字段，该子语句仅针对原生 SerDe 属性的表有效（DynamicSerDe, MetadataTypedColumnsetSerDe, LazySimpleSerDe 和 ColumnarSerDe），REPLACE COLUMNS 也可以用来删除字段，比如 <code>ALTER TABLE test_change REPLACE COLUMNS (a int, b int);</code> 就会删除原表字段 c</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_show">3.6. SHOW</h3>
<div class="paragraph">
<p>SHOW 包含了一系列子语句，用来查询数据库、表、分区等的元数据信息</p>
</div>
<div class="sect3">
<h4 id="show_databases">3.6.1. Show Databases</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">SHOW (DATABASES|SCHEMAS) [LIKE 'identifier_with_wildcards'];</code></pre>
</div>
</div>
<div class="paragraph">
<p>SHOW DATABASES|SCHEMAS 列出在元数据库中存储的所有数据库。这里 DATABASE 和 SCHEMA 是等价的。</p>
</div>
<div class="paragraph">
<p>可选的 LIKE 子句可以使用正规表达式来过滤数据库，不过表示通配符的只要能还是用表示任意字符的 '<strong>' 和表示选择的 '|'。
比如， ' employees','emp</strong>','emp*|*ees' 都可以匹配名为 'employees' 的数据库。</p>
</div>
</div>
<div class="sect3">
<h4 id="_show_tables_partitions_indexes">3.6.2. Show Tables/Partitions/Indexes</h4>
<div class="listingblock">
<div class="title">显示数据库</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">SHOW TABLES [IN database_name] ['identifier_with_wildcards'];</code></pre>
</div>
</div>
<div class="paragraph">
<p>SHOW TABLES 列出当前数据库下的所有表以及视图（或者用 IN 子句显式指定数据库），也可以使用正规表达式方式来过滤表和视图，表达式使用方式见 <a href=":">show_databases</a></p>
</div>
<div class="listingblock">
<div class="title">显示分区</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">SHOW PARTITIONS table_name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>SHOW PARTITIONS 按字母排序列出指定表的所有已经存在的分区。</p>
</div>
<div class="paragraph">
<p>我们也可以通过指定分区规格来过滤分区结果，下面是几个例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">SHOW PARTITIONS table_name PARTITION(ds='2010-03-03');
SHOW PARTITIONS table_name PARTITION(hr='12');
SHOW PARTITIONS table_name PARTITION(ds='2010-03-03', hr='12');</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">扩展显示表/分区</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">SHOW TABLE EXTENDED [IN|FROM database_name] LIKE 'identifier_with_wildcards' [PARTITION(partition_spec)];</code></pre>
</div>
</div>
<div class="paragraph">
<p>SHOW TABLE EXTENDED 列出所有匹配的表的信息，这些信息除了表的基本信息外，还包括系统信息，比如totalNumberFiles, totalFileSize, maxFileSize, minFileSize,lastAccessTime, and lastUpdateTime。如果指定了分区，则是显示分区的系统信息而不是表的系统信息。</p>
</div>
<div class="paragraph">
<p>注意，如果指定了表分区，那么指定表时不能使用正规表达式。</p>
</div>
<div class="paragraph">
<p>以下是使用例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt;show table extended like sample_07;
tab_name
tableName:sample_07
owner:hive
location:hdfs://localhost:8020/apps/hive/warehouse/sample_07
inputformat:org.apache.hadoop.mapred.TextInputFormat
outputformat:org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat
columns:struct columns { string code, string description, i32 total_emp, i32 salary}
partitioned:false
partitionColumns:
totalNumberFiles:1
totalFileSize:46055
maxFileSize:46055
minFileSize:46055
lastAccessTime:1473765425609
lastUpdateTime:1473765437939

15 rows selected (0.095 seconds)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">显示表属性</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">SHOW TBLPROPERTIES tblname;
SHOW TBLPROPERTIES tblname("foo");</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个语句列出表 tblname 的所有属性，每行一个。第二语句列出表 tblname 的属性 foo 的值。</p>
</div>
<div class="listingblock">
<div class="title">显示创建表</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">SHOW CREATE TABLE ([db_name.]table_name|view_name);</code></pre>
</div>
</div>
<div class="paragraph">
<p>SHOW CREATE TABLE 语句显示创建表或视图(CREATE TABLE)的语句，以下是例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; show create table sample_07;
CREATE TABLE `sample_07`(
  `code` string,
  `description` string,
  `total_emp` int,
  `salary` int)
ROW FORMAT DELIMITED
  FIELDS TERMINATED BY '\t'
STORED AS INPUTFORMAT
  'org.apache.hadoop.mapred.TextInputFormat'
OUTPUTFORMAT
  'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat'
LOCATION
  'hdfs://localhost:8020/apps/hive/warehouse/sample_07'
TBLPROPERTIES (
  'numFiles'='1',
  'numRows'='0',
  'rawDataSize'='0',
  'totalSize'='46055',
  'transient_lastDdlTime'='1473765438')
19 rows selected (0.26 seconds)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_显示字段">3.6.3. 显示字段</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">SHOW COLUMNS (FROM|IN) table_name [(FROM|IN) db_name];</code></pre>
</div>
</div>
<div class="paragraph">
<p>SHOW COLUMNS 显示一个表的所有字段信息，包括分区字段</p>
</div>
</div>
<div class="sect3">
<h4 id="_显示函数">3.6.4. 显示函数</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">SHOW FUNCTIONS LIKE "a.*"</code></pre>
</div>
</div>
<div class="paragraph">
<p>列出所有匹配的用户自定义和内置的函数名称。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_describe">3.7. Describe</h3>
<div class="listingblock">
<div class="title">描述数据库</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">DESCRIBE DATABASE [EXTENDED] db_name;
DESCRIBE SCHEMA [EXTENDED] db_name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>DESCRIBE DATABASE 显示数据库的名字，注释，在文件系统上的路径，EXTENDED 可以显示数据库的属性。</p>
</div>
<div class="paragraph">
<div class="title">描述表/视图/字段</div>
<p>有两种语法来描述描述表/视图/字段，取决于你是否指定了数据库。</p>
</div>
<div class="paragraph">
<p>如果数据库没有指定，可选的字段信息跟在表后，中间有点(.)连接，语法如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">DESCRIBE [EXTENDED|FORMATTED]
  table_name[.col_name ( [.field_name] | [.'$elem$'] | [.'$key$'] | [.'$value$'] )* ];</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果指定了数据库，那么字段和表之间用空格连接</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">DESCRIBE [EXTENDED|FORMATTED]
  [db_name.]table_name[ col_name ( [.field_name] | [.'$elem$'] | [.'$key$'] | [.'$value$'] )* ];</code></pre>
</div>
</div>
<div class="paragraph">
<p>DESCRIBE 列出指定表的字段信息，包括分区字段。如果指定了 EXTENDED 关键字，还会显示表的元数据信息，Thrift 序列化格式，通常用于调试。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hive_dml">4. Hive DML</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_概述_2">4.1. 概述</h3>
<div class="paragraph">
<p>本章描述 Hive 支持的基本 DML 语句，大致上 Hive 的 RDBMS 的 DML 语句类似，但也有其特殊的地方。</p>
</div>
</div>
<div class="sect2">
<h3 id="_加载文件到表">4.2. 加载文件到表</h3>
<div class="paragraph">
<p>Hive 并不支持加载数据到表时进行转换。加载操作只是纯粹的拷贝/移动数据文件到表对应的物理路径上</p>
</div>
<div class="listingblock">
<div class="title">语法</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">LOAD DATA [LOCAL] INPATH 'filepath' [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1=val1, partcol2=val2 ...)]</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>filepath</em> 可以是：</p>
<div class="ulist">
<ul>
<li>
<p>相对径路，比如 <em>project/data1</em></p>
</li>
<li>
<p>绝对路径，比如 <em>/user/hive/project/data1</em></p>
</li>
<li>
<p>完整的 URI 以及认证信息，比如 <em>hdfs://namenode:8020/user/hive/project/data1</em></p>
</li>
</ul>
</div>
</li>
<li>
<p>加载的目标可以是表，也可以是分区，如果表是分区表，则需要指定是哪个分区</p>
</li>
<li>
<p><em>filepath</em> 可以是一个文件，也可以是一个目录，如果是后者，Hive 则把目录下的所有文件都加载到目标对象中</p>
</li>
<li>
<p>如果关键字 LOCAL 指定的话，那么：</p>
<div class="ulist">
<ul>
<li>
<p>load 命令将在本地文件系统上寻找 <em>filepath</em> ，如果 <em>filepath</em> 是相对路径，则把用户的当前工作目录作为根目录，对于本地文件，用户可以使用 URI 方式来指定，比如 <code><a href="file://data/project/data1" class="bare">file://data/project/data1</a></code></p>
</li>
<li>
<p>load 命令会先把所有的文件拷贝到目标文件系统上（这里一般是 HDFS），而后把数据文件移动到表或分区对应的物理路径上</p>
</li>
</ul>
</div>
</li>
<li>
<p>如果没有指定关键字 LOCAL，Hive 或者使用 <em>filepath</em> 的网站 URI（如果指定了 URI），或者使用以下规则：</p>
<div class="ulist">
<ul>
<li>
<p>如果模式（scheme）或认证没有指定，Hive 将从 hadoop 的配置变量 <code>fs.default.name</code> 中获取 Namenode 的 URI 作为当前 <em>filepath</em> 的 URI</p>
</li>
<li>
<p>如果 <em>filepath</em> 不是绝对路径，那么 Hive 用 <em>/user/&lt;username&gt;</em> 作为绝对路径前缀</p>
</li>
<li>
<p>Hive 将移动 <em>filepath</em> 指定的文件或目录到表或分区对一个的目录下</p>
</li>
</ul>
</div>
</li>
<li>
<p>如果指定了 OVERWRITE 关键字，那么目标表或分区的数据会先删除，然后再加载；否则数据文件追加到目标表或分区上</p>
<div class="ulist">
<ul>
<li>
<p>注意，如果目标表或分区的数据文件名和要加载的数据文件名重名，那么原来的数据文件将会被替换</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">注意</div>
<ul>
<li>
<p><em>filepath</em> 不能包含子目录</p>
</li>
<li>
<p>如果没有指定 LOCAL 关键字，<em>filepath</em> 所指定的文件或目录必须和表或分区在同一个文件系统上</p>
</li>
<li>
<p>Hive 对要加载的文件仅作做基本的检查，当前仅检查文件的格式是否和表或分区指定的存储相同</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_把查询结果插入数据到表">4.3. 把查询结果插入数据到表</h3>
<div class="paragraph">
<p>查询结果也可以插入到表中</p>
</div>
<div class="listingblock">
<div class="title">语法</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">-- Standard syntax:
INSERT OVERWRITE TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 ...) [IF NOT EXISTS]] select_statement1 FROM from_statement;
INSERT INTO TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 ...)] select_statement1 FROM from_statement;
INSERT INTO TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 ...)] (z,y) select_statement1 FROM from_statement;

-- Hive extension (multiple inserts):
FROM from_statement
INSERT OVERWRITE TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 ...) [IF NOT EXISTS]] select_statement1
[INSERT OVERWRITE TABLE tablename2 [PARTITION ... [IF NOT EXISTS]] select_statement2]
[INSERT INTO TABLE tablename2 [PARTITION ...] select_statement2] ...;
FROM from_statement
INSERT INTO TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 ...)] select_statement1
[INSERT INTO TABLE tablename2 [PARTITION ...] select_statement2]
[INSERT OVERWRITE TABLE tablename2 [PARTITION ... [IF NOT EXISTS]] select_statement2] ...;

-- Hive extension (dynamic partition inserts):
INSERT OVERWRITE TABLE tablename PARTITION (partcol1[=val1], partcol2[=val2] ...) select_statement FROM from_statement;
INSERT INTO TABLE tablename PARTITION (partcol1[=val1], partcol2[=val2] ...) select_statement FROM from_statement;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">解释</div>
<ul>
<li>
<p>INSERT OVERWRITE 会覆盖目标表或分区的数据</p>
</li>
<li>
<p>INSERT INTO 把数据追加到目标表或分区的最后，原来的数据不变</p>
</li>
<li>
<p>多表插入是 Hive 的独有特性，从一个查询语句中，依据条件分支不同，将数据插入到不同的表中，不同的条件可以分别确定是采取 INSERT OVERWRITE 方式还是 INSERT INTO 方式</p>
</li>
<li>
<p>INSERT INTO 后面的表可以指定字段，比如 <code>INSERT INTO T (z, x, c1)</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_动态分区插入">4.3.1. 动态分区插入</h4>
<div class="paragraph">
<p>在动态分区插入中，用户可以只给出分区的部分规范，这意味着只需要在 PARTITION 子句中指定分区字段的名字，而分区字段的值是可选的。
如果分区字段的值给定了，我们则成为静态插入，否则就是动态插入。每一个动态分区字段在后面的 select 语句中都有对应的输入字段。
动态分区字段必须出现在 select 语句的最后，且多个动态分区字段的顺序必须和 PARTITION()子句中出现的字段顺序保持一致。</p>
</div>
<div class="paragraph">
<p>与动态分区插入相关的配置参数和解释如下表：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">配置参数</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hive.exec.dynamic.partition</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置为 true 启用动态分区插入功能</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hive.exec.dynamic.partition.mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">strict</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在 strict 模式下，用户必须指定至少一个静态分区，在 nonstrict 模式下，所有的分区都允许是动态分区插入</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hive.exec.max.dynamic.partitions.pernode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许每个 mapper/reduce 节点最大的动态分区数量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hive.exec.max.dynamic.partitions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许可以创建的最大动态分区数量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hive.exec.max.created.files</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100,000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在一个 MR 任务里可以创建的最大 HDFS 文件数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hive.error.on.empty.partition</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果一个动态分区插入为空结果是否抛出异常</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">例子</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">FROM page_view_stg pvs
INSERT OVERWRITE TABLE page_view PARTITION(dt='2015-06-08', country)
       SELECT pvs.viewTime, pvs.userid, pvs.page_url, pvs.referrer_url, null, null, pvs.ip, pvs.cnt</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述语句中，country 分区字段为动态插入，对应的分区值由 select 语句的最后字段-- 这里是 pvs.cnt&#8201;&#8212;&#8201;来决定。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_把查询结果写入文件系统">4.4. 把查询结果写入文件系统</h3>
<div class="paragraph">
<p>一个 SQL 的查询结果也可以直接写入到文件系统的目录中，其语法和结果写入到表类似。</p>
</div>
<div class="listingblock">
<div class="title">语法</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">-- Standard syntax:
INSERT OVERWRITE [LOCAL] DIRECTORY directory1
  [ROW FORMAT row_format] [STORED AS file_format]
  SELECT ... FROM ...

-- Hive extension (multiple inserts):
FROM from_statement
INSERT OVERWRITE [LOCAL] DIRECTORY directory1 select_statement1
[INSERT OVERWRITE [LOCAL] DIRECTORY directory2 select_statement2] ...

row_format
  : DELIMITED [FIELDS TERMINATED BY char [ESCAPED BY char]] [COLLECTION ITEMS TERMINATED BY char]
        [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char]
        [NULL DEFINED AS char]</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">解释</div>
<ul>
<li>
<p>目录必须是完整的 URI。如果模式或认证没有指定，Hive 从 hadoop 的配置项 <code>fs.default.name</code> 中获取</p>
</li>
<li>
<p>如果使用了 LOCAL 关键字，Hive 将数据写入到本地文件系统的目录上</p>
</li>
<li>
<p>数据以文本格式写入到文件系统，字段之间用 ^A 分隔，记录之间用换行。如果字段不是基本类型，则这些字段的数据序列化成 JSON 格式</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_从_sql_插入数据到表">4.5. 从 SQL 插入数据到表</h3>
<div class="paragraph">
<p>INSERT &#8230;&#8203; VALUES 语句可以用来直接从 SQL 语句插入数据到表中。</p>
</div>
<div class="listingblock">
<div class="title">语法</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">-- Standard Syntax:
INSERT INTO TABLE tablename [PARTITION (partcol1[=val1], partcol2[=val2] ...)] VALUES values_row [, values_row ...]

Where values_row is:
( value [, value ...] )
where a value is either null or any valid SQL literal</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">解释</div>
<ul>
<li>
<p>在 VALUES 子句中，表的每个字段的值都必须给出，标准 SQL 中，允许指定一部分字段然后进行插入，目前 Hive 还不支持这个特性</p>
</li>
<li>
<p>该语法同样支持动态分区插入</p>
</li>
<li>
<p>如果 Hive 启用了 ACID 特性，则插入采取自动提交特性，即没插入一行成功，则提交一次</p>
</li>
<li>
<p>该语法不支持复杂类型（比如 array，map，struct，union）的插入</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">例子</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">CREATE TABLE students (name VARCHAR(64), age INT, gpa DECIMAL(3, 2))
  CLUSTERED BY (age) INTO 2 BUCKETS STORED AS ORC;

INSERT INTO TABLE students
  VALUES ('fred flintstone', 35, 1.28), ('barney rubble', 32, 2.32);


CREATE TABLE pageviews (userid VARCHAR(64), link STRING, came_from STRING)
  PARTITIONED BY (datestamp STRING) CLUSTERED BY (userid) INTO 256 BUCKETS STORED AS ORC;

INSERT INTO TABLE pageviews PARTITION (datestamp = '2015-09-23')
  VALUES ('jsmith', 'mail.com', 'sports.com'), ('jdoe', 'mail.com', null);

INSERT INTO TABLE pageviews PARTITION (datestamp)
  VALUES ('tjohnson', 'sports.com', 'finance.com', '2015-09-23'), ('tlee', 'finance.com', null, '2015-09-21');</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_更新">4.6. 更新</h3>
<div class="paragraph">
<p>更新（Update）并不是一开始就被 Hive 支持的，而是在 Hive 0.14以后才增加的版本，要使用该功能，必须启用 ACID 特性。</p>
</div>
<div class="listingblock">
<div class="title">语法</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">UPDATE tablename SET column = value [, column = value ...] [WHERE expression]</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">解释</div>
<ul>
<li>
<p>更新的值必须是 Hive 支持的表达式，比如算术操作、UDF、cast、字符等都可以，但是子查询不支持</p>
</li>
<li>
<p>只有匹配 WHERE 子句的行会被更新</p>
</li>
<li>
<p>分区字段不能更新</p>
</li>
<li>
<p>桶字段不能更新</p>
</li>
<li>
<p>一旦更新操作完成，则会自动提交</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_删除">4.7. 删除</h3>
<div class="paragraph">
<p>删除(Delete) 和更新操作一样，也需要在启动 ACID 特性下才支持。</p>
</div>
<div class="listingblock">
<div class="title">语法</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">DELETE FROM tablename [WHERE expression]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hive_udf">5. Hive 自定义函数</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hive 支持一系列函数，这些函数包括内建的普通函数（UDF），内建的聚合函数（UDAF），内建的表生成函数（UDTF）等。</p>
</div>
<div class="sect2">
<h3 id="_内建函数">5.1. 内建函数</h3>
<div class="sect3">
<h4 id="_数学函数">5.1.1. 数学函数</h4>
<div class="paragraph">
<p>以下是 Hive 内置的数学函数，这些函数在参数为空的情况，大部分返回为空。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">返回类型</th>
<th class="tableblock halign-left valign-top">函数名（注册名）</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">round(DOUBLE a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a 的四舍五入整数的浮点数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">round(DOUBLE a, INT d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a 的四舍五入数，小数点位数不超过 d 位</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bround(DOUBLE a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回针对 a 的高斯舍入或银行家算法舍入方式的值，比如 bround(2.5) = 2,bround(3.5) = 4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bround(DOUBLE a, INT d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回针对 a 的高斯舍入或银行家算法舍入方式的值，小数点后最多保留 d 位。比如 bround(8.25,1) = 8.2,bround(8.35,1) = 8.4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">floor(DOUBLE a )</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回不大于 a 的最大整数，即地板取整</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ceil(DOUBLE a),celling(DOUBLE a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回不小于 a 的最小证书，即天花板取整</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rand(),rand(INT seed)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回0到1之间的随机数，也可以指定随机种子 seed</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">exp(DOUBLE a),exp(DECIMAL a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 e^a 的结果，其中 e 为自然对数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ln(DOUBLE a), ln(DECIMAL a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回以自然对数 e 为底,数 a 的对数值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">log10(DOUBLE a), log10(DECIMAL a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回以10为底的数 a 的对数值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">log2(DOUBLE a), log2(DECIMAL a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回以10为底的数 a 的对数值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">log(DOUBLE base,DOUBLE a), log2(DECIMAL base,DECIMAL a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回以base为底的数 a 的对数值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">pow(DOUBLE a, DOUBLE p), power(DOUBLE a, DOUBLE p)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a^p 的值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sqrt(DOUBLE a), sqrt(DECIMAL a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a 的平方根值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">STRING</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bin(BIGINT a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回数 a 的二进制格式，比如 bin(12) 返回 1100</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">STRING</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hex(BIGINT a) hex(STRING a) hex(BINARY a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果参数是整数或二进制数，该函数返回其字符串形式的十六进制数。如果参数是字符串，则
函数把每个字符转为十六进制数然后返回。比如 hex(23) = '17' , hex('23') = '3233'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BINARY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unhex(STRING a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hex 函数的反函数，把每一对字符当做十六进制翻译，然后转为字节码，比如 unhex('3233') = 23</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">STRING</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">conv(BIGINT num, INT from_base, INT to_base), conv(STRING num, INT from_base, INT to_base)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">进制转换函数把 num 从 from_base 进制转为 to_base 进制，比如 conv(12,16,2) = '10010', conv('12',16,2) = '10010'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">abs(DOUBLE a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a 的绝对值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT/DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">pmod(INT a, INT b), pmod(DOUBLE a, DOUBLE b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a 模 b 的结果</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sin(DOUBLE a), sin(DECIMAL a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a 的正弦值，a 为弧度值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">asin(DOUBLE a), asin(DECIMAL a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">计算 a 的反正弦函数，如果 -1 ≤ a ≤ 1,否则返回 NULL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cos(DOUBLE a), cos(DECIMAL a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a 的余弦值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">acos(DOUBLE a), acos(DECIMAL a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a 的反余弦值，如果 -1 ≤ a ≤ 1,否则返回 NULL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tan(DOUBLE a), tan(DECIMAL a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a 的正切值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">atan(DOUBLE a), atan(DECIMAL a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a 的反正切值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">degrees(DOUBLE a), degrees(DECIMAL a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把 a 从弧度制转为角度值，比如 degrees(3.14159267) = 180.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">radians(DOUBLE a), radians(DOUBLE a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把 a 从角度值转为弧度制，比如 radians(90) = 1.570</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT /DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">positive(INT a), positive(DOUBLE a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT /DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">negative(INT a), negative(DOUBLE a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 -a</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE/INT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sign(DOUBLE a), sign(DECIMAL a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果a 为正数，返回1.0，如果为负数返回-1.0，否则返回0.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">e()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回自然对数值(2.718281828459045)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">pi()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回圆周率值(3.141592653589793)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">factorial(INT a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a 的阶乘结果，a 的取值范围为[0,20]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cbrt(DOUBLE a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a 的立方根</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT/BIGINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">shiftleft(TINYINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SMALLINT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT a, INT b),shiftleft(BIGINT a, INT b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a 位左移2位的结果</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT/BIGINT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">shiftright(TINYINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SMALLINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT a, INT b),shiftright(BIGINT a, INT b)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a 位右移2位的结果</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT/BIGINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">shiftrightunsigned(TINYINT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SMALLINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT a, INT b),shiftrightunsigned(BIGINT a, INT b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 a 位右移2位的无符号数结果</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">greatest(T v1, T v2, &#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回所有参数中数值最大的值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">least(T v1, T v2, &#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回所有参数中数值最小的值</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_集合函数">5.1.2. 集合函数</h4>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">返回类型</th>
<th class="tableblock halign-left valign-top">函数名</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">size(Map&lt;K,V&gt;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 map 类型的元素个数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">size(Array&lt;T&gt;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 array 类型的元素个数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">array&lt;K&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">map_keys(Map&lt;K,V&gt;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 map 的键无序集合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">array&lt;K&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">map_values(Map&lt;K,V&gt;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 map 的值无序集合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">array_contains(Array&lt;T&gt;,value)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果数组 T 包含值 value，返回为TRUE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">array&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">stor_array(Array&lt;T&gt;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对数组 T 进行自然升序排列后返回</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_类型转换函数">5.1.3. 类型转换函数</h4>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">返回类型</th>
<th class="tableblock halign-left valign-top">函数名</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">binary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">binary(string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">binary)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">把参数转为二进制数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;type&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cast(expre as &lt;type&gt;)</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_日期函数">5.1.4. 日期函数</h4>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">返回类型</th>
<th class="tableblock halign-left valign-top">函数名</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">from_unixtime(bigint unixtime[, string format])</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把 unix 时间戳转为字符串时间表达形式，比如 from_unixtime(1425115821) = '2015-02-28 17:30:21'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bigint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unix_timestamp()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获得当前 unix 时间戳，单位为秒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bigint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unix_timestamp(string date)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">转换指定日期的 unix 时间戳，date 格式为 yyyy-MM-dd HH:mm:ss，转换失败则返回为0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">to_date(string timestamp)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回指定时间的日期部分，比如 to_date('2015-02-28 17:30:21') = '2015-02-28'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">year(string date)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回日期或者时间戳的年份</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">month(string date)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回日期的月份</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">day(string date),dayofmonth(date)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回日期的天</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hour(string date)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回日期的小时部分值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">minute(string date)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回日期的分钟部分值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">second(string date)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回日期的秒钟部分值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">weekofyears(string date)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回指定日期属于当年的第几周</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">datediff(string enddate,string startdate)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回两个日期相差的天数，比如 datediff('2015-10-12','2015-9-3') = 39</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">date_add(string startdate,int days)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回在 startdate 日期后 days 天的日期，比如 date_add('2015-9-3',39) = '2015-10-12'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">date_sub(string startdate,int days)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 startdate 日期前 days 天的日期，比如 date_sub('2015-10-12',39) = '2015-09-03'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">timestamp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">from_utc_timestamp(timestamp,string timezone)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假定给出的时间戳是 UTC 时区，转换为 timezone 时区后返回，比如 from_utc_timestamp('2015-10-12 00:00:00','CST') =  '2015-10-11 19:00:00.0'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">timestamp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">to_utc_timestamp(timestamp,string timezone)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假定给出的时间戳以及timezone 时区转为 UTC 时区值返回，比如 to_utc_timestamp('2015-10-12 00:00:00','CST') =  '2015-10-12 05:00:00.0'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">date</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">current_date</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回当前日期</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">timestamp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">current_timestamp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回当前日期的时间戳</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">add_month(string startdate,int months)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 startdate 日期后 months 月的日期</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">last_day(string date)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回日期属于月份的最后一天的日期，比如 last_day('2015-10-12') = '2015-10-31'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">next_day(string start_date, string day_of_week)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回晚于 start_date，但不早于 day_of_week 给定的星期的日期，day_of_week 可以使用2字母，3字母或星期全拼表达，比如 next_day('2015-10-23','TU') = '2015-10-27' ，2015-10-23 是星期五，比这个时间晚，但不要超过 TU 也即是星期二，所以是2015-10-27，这天是星期二</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">trunc(string date,string format)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">清空 date 日期的 format 部分后的所有时间，然后返回。比如 trunc('2015-12-23','MM') = '2015-12-01',trunc('2015-12-23','YYYY') = '2015-01-01'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">month_between(date1,date2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回两个日期相差的月份值，比如 months_between('2015-12-20','2015-09-12') =  3.25806452, months_between('2015-09-20','2015-12-20') = -3.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">date_format(date/timestamp/strings,string format)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把时间转为指定的格式，format 支持的格式为 Java SimpleDateFormat 格式，可以参考<a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html">SimpleDateFormat</a></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_额外函数">5.1.5. 额外函数</h4>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">返回类型</th>
<th class="tableblock halign-left valign-top">函数名</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if(boolean testCondition, T valueTrue,T valueFalseorNull)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果条件 testCondition 为真，返回 valueTrue，否则返回 valueFalseorNull</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">isnull(a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果 a 为 NULL，返回真，否则返回假</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">isnotnull(a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果 a 不为 NULL，返回真，否则返回假</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">nvl(T value, T default_value)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果 value 值为空则返回 default_value，否则返回 value 值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">coalesce(T v1, T v2, &#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果不为空，返回第一个 v 的值，否则如果所有的 v 都是 NUll，则返回 NULL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CASE a WHEN b THEN c [WHEN d THEN e]* [ELSE f] END</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当 a = b ，返回 c；当 a = d，返回 e；否则返回 f</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CASE WHEN a THEN b [WHEN c THEN d]* [ELSE e] END</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当 a = true，返回 b； 当 c = true，返回 d；否则返回 e</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">nullif(a,b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果 a = b ，返回 NULL；否则返回 a。是 CASE WHEN a = b then NULL else a 简洁表示法</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_字符串函数">5.1.6. 字符串函数</h4>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">返回类型</th>
<th class="tableblock halign-left valign-top">函数名</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">base64(binary bin)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把二进制数 bin 转为 base64编码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">chr(bigint|double A)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 A 等价的 ascii 字符，如果 A 大于256,则返回 chr(A % 256) 的结果。比如: chr(88) =  "X".</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">concat(string|binary A, string|binary B&#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回按参数顺序拼接后的字符串，比如 concat('foo', 'bar') =  'foobar'.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">concat_ws(string SEP, string A, string B&#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类似 concat() , 但可以把拼接的分隔符自定义为 SEP.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">concat_ws(string SEP, array&lt;string&gt;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类似 concat_ws() , 只是参数形式为数组</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">decode(binary bin, string charset)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把第一个参数按照给定的字符集 charset 进行解码 (字符集可以为 'US-ASCII', 'ISO-8859-1', 'UTF-8', 'UTF-16BE', 'UTF-16LE', 'UTF-16'). 任意参数为空，返回结果为空。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">format_number(number x, int d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">格式化数字 x 为类似 <code><mark>,<mark></mark>,</mark><mark>.</mark>#</code> 的格式。d 为小数位个数，如果 d 为0 ，则没有小数部分。比如 format_number(34523454,2) = '4,523,454.00', format_number(34523454) = '4,523,454'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">get_json_object(string json_string, string path)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从一个 json 字符串中，根据给定的json 路径 path 提取出对应的 json 对象。如果给定的 json 字符串无效，则返回 NULL。 注意: json path 只能能包含 [0-9a-z_] 这些字符, 不包括大写字符或特殊字符。同时不能以数字开头。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lower(string A) lcase(string A)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回给定字符 A 的所有小写形式的字符串。比如， lower('fOoBaR') = 'foobar'.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lpad(string str, int len, string pad)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回用 pad 字符左侧填充字符串 str 到长度为 len 的字符串。比如 lpad('abc',4,'*') = '*abc'。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ltrim(string A)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回截取掉字符串 A 左侧的空白字符后的字符串。 ltrim(' foobar ') =  'foobar '.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">parse_url(string urlString, string partToExtract [, string keyToExtract])</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从给定的 URL 字符串中返回特定的部分。partToExtract 的有效值包括 HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, 和 USERINFO. 比如 parse_url('http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1', 'HOST') = 'facebook.com'. 另外，查询部分的提取，可以通过指定第三个参数 keyToExtract 来获取。 比如， parse_url('http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1', 'QUERY', 'k1') = 'v1'.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">printf(String format, Obj&#8230;&#8203; args)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回按照 printf 函数风格格式化的字符换。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">regexp_extract(string subject, string pattern, int index)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从字符串 subject 中按给定的正规表式 pattern 来提取字符串。 参数 index 表示提取匹配的哪个部分。regexp_extract('foothebar', 'foo(.*?)(bar)', 2) = 'bar'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">regexp_replace(string INITIAL_STRING, string PATTERN, string REPLACEMENT)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用 REPLACEMENT 按照正规表达式 PATTERN 的规则对字符串进行 INITIAL_STRING 匹配替换，然后返回替换后的字符串。比如， regexp_replace("foobar", "oo|ar", "") = 'fb'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">repeat(string str, int n)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字符串 str 重复 n 的结果</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">replace(string A, string OLD, string NEW)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回用 NEW 替代字符串 A 所有包含字符串 OLD 后的字符串。  比如:  replace("ababab", "abab", "Z") =  "Zab".</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reverse(string A)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字符串 A 的反序字符串</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rpad(string str, int len, string pad)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回用 pad 右侧填充字符串 str 到长度为 len 后的字符串。比如：rpad('abc',4,'<strong>') = 'abc</strong>'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rtrim(string A)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回接去掉字符串 A 的所有右侧空白字符后的字符。 比如： rtrim(' foobar ') = ' foobar'.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">space(int n)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回 n 个空格的字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">substr(string|binary A, int start), substring(string|binary A, int start)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字符串 A 的字串。参数 start 表示从什么位置开始截取，注意：位置从1开始计数。比如： substr('foobar', 4) = 'bar'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">substr(string|binary A, int start, int len),substring(string|binary A, int start, int len)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回从字符串 A 截取从位置 start 开始长度为 len 的字串。比如： substr('foobar', 4, 1) = 'b'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">substring_index(string A, string delim, int count)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字符串 A 出现界定符 delim 之前的所有字符。如果参数 count 是正数，表示从左边开始数起，到 delim 出现次数不超过 count 之前的字符串都返回。如果是负数，则从右往左数起。 Substring_index 是区分大小写的。 比如: substring_index('www.apache.org', '.', 2) = 'www.apache', substring_index('www.apache.org', '.', -2) = 'apache.org'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">translate(string|char|varchar input, string|char|varchar from, string|char|varchar to)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">翻译字符串 input，把 input 中出现在 from 里的字符都用对应 to 里的字符替换，然后返回。其功能类似于 PostgreSQL  里的<a href="http://www.postgresql.org/docs/9.1/interactive/functions-string.html">翻译函数</a>，任意参数为空，则返回的结果为空。 比如 translate('abcd','ab','AB') = 'ABcd'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">trim(string A)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回去掉字符串 A 的左右侧空白字符后的字符串。比如： trim(' foobar ') = 'foobar'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">upper(string A) ucase(string A)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字符串 A 的大写形式。比如：upper('fOoBaR') = 'FOOBAR'.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">initcap(string A)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字符串 A 的每个单词首字符大写后的字符串。比如 initcap('to be ,or not to be,that's a question') = ' To Be ,or Not To Be,that's A Question'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">soundex(string A)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字符串的语音表示法结果。比如： soundex('Miller') =  M460.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">map&lt;string,string&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">str_to_map(text[, delimiter1, delimiter2])</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把文本 text 按照两个界定符 delimiter1 和 delimiter2 来分割成 key-value 对。界定符 Delimiter1 用来分割文本为每一个 K-V
 字符对，界定符 Delimiter2 用来把 K-V 字符对分割成 K-V 对。比如：str_to_map('one=1,two=2,three=3',',','=') = {"three":"3","one":"1","two":"2"}</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ascii(string str)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字符串 str 的第一个字符的 ascii 码。比如： ascii('abc') = 97</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">find_in_set(string str, string strList)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字符串 str 在字符串 strList 第一次出现的位置。strList 是一个逗号分隔的字符串列表。任意参数为 NULL，则返回为 NULL，如果第一个参数包含逗号(,—)，则返回0。比如： find_in_set('ab', 'abc,b,ab,c,def') =  3，find_in_set('ab,', 'abc,b,ab,c,def')  = 0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">instr(string str, string substr)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字符串 substr 首次出现在字符串 str 的位置。任意参数为 NULL，则返回为 NULL。如果字符没有找到，则返回为0。注意：这里字符串的索引从1而不是从0开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">length(string A)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字符串 A 的长度</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">locate(string substr, string str[, int pos])</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字符串 str 的 pos 位置后首次出现 substr 的位置。如果没有自定 pos，则从头开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">levenshtein(string A, string B)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回两个字符串的  Levenshtein 距离。 比如： levenshtein('kitten', 'sitting') =  3.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">in_file(string str, string filename)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果字符串 str 作为整行出现在字符串 filename 中，返回真。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">binary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">encode(string src, string charset)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用指定的的字符集 charset 编码字符串 src 为二进制格式。 (字符集可以为 'US-ASCII', 'ISO-8859-1', 'UTF-8', 'UTF-16BE', 'UTF-16LE', 'UTF-16'). 任意参数为NULL，则返回 NULL。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">binary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unbase64(string str)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回对字符串 str 进行 base64 解码后的字节码。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<div class="title">get_json_object</div>
<p>当前对 JSON path 的支持如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$: 根对象</p>
</li>
<li>
<p>.: 子操作符</p>
</li>
<li>
<p>[]: 针对数组的子操作符</p>
</li>
<li>
<p>*: 针对[]的通配符</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下方法不支持：
* : 空字符串作为 key
* .. : 递归下降
* @ : 当前对象、元素
* () : 脚本表达式
* ?() : 过滤（脚本）表达式
* [,] : 联合操作符
* [start:end.step] : 数组分片操作符</p>
</div>
<div class="paragraph">
<p>假定一个 json 字符串如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="json">{"store":
  {"fruit":[{"weight":8,"type":"apple"},{"weight":9,"type":"pear"}],
   "bicycle":{"price":19.95,"color":"red"}
  },
 "email":"amy@only_for_json_udf_test.net",
 "owner":"amy"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下是针对该 json 串的一些操作示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">hive&gt; SELECT get_json_object(src_json.json, '$.owner') FROM src_json;
amy

hive&gt; SELECT get_json_object(src_json.json, '$.store.fruit\[0]') FROM src_json;
{"weight":8,"type":"apple"}

hive&gt; SELECT get_json_object(src_json.json, '$.non_exist_key') FROM src_json;
NULL</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_其他函数">5.1.7. 其他函数</h4>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">返回类型</th>
<th class="tableblock halign-left valign-top">函数名</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">varies</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java_method(class,method[,arg1[,arg2&#8230;&#8203;]])</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">等同于 reflect</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">varies</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reflect(class,method[,arg1[,arg2&#8230;&#8203;]])</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">调用 java 方法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hash(a1[,a2..])</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回参数的 hash 值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">current_user()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回当前用户名</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">current_database()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回当前正在使用的数据库名</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">md5(string|binary)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">计算参数的MD5值，返回的结果为32位长度的字符串，如果参数为 NULL，则返回结果为 NULL。比如 md5('abc') = '900150983cd24fb0d6963f7d28e17f72'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sha1(string|binary),sha(string|binary)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">计算参数的 SHA-1 数字摘要结果。比如： sha1('abc') = 'a9993e364706816aba3e25717850c26c9cd0d89d'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">binary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">aes_encrypt(string|binary input,string|binary key)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 AES 算法对参数 input 加密并返回加密结果。key 的长度必须为128，192或256位。如果任意参数为 NULL 或者 key 的长度不符合定义则返回的结果为 NULL。比如 base64(aes_encrypt('hello','1234567890123456')) = '67fHA+Z12z2jlwOLTBeCPA=='</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">binary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">aes_decrypt(string|binary input,string|binary key)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 AES 算法对参数 input 解密并返回解密结果。key 的长度必须为128，192或256位。如果任意参数为 NULL 或者 key 的长度不符合定义则返回的结果为 NULL。比如 aes_decrypt(unbase64('67fHA+Z12z2jlwOLTBeCPA=='),'1234567890123456') = 'hello'</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_内建的聚合函数">5.2. 内建的聚合函数</h3>
<div class="paragraph">
<p>以下是 Hive 当前支持的内建聚合函数(Built-in Aggregate Functions,a.k.a UDAF)</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">返回类型</th>
<th class="tableblock halign-left valign-top">函数名</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bigint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">count(\*),count(expr),count(distinct expr[,expr&#8230;&#8203;])</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">count(\*) - 统计返回行的总数，包含行为空的情况; count(expr)&#8201;&#8212;&#8201;返回符合表达式 expr 的行的总数；count(distinct expr[,expr&#8230;&#8203;]) 返回符合表达 expr 的去重记录数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sum(col),sum(distinct col)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">计算指定字段的累加结果，如果指定了 distinct 关键字，则对字段 col 去重后再计算</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">avg(col),avg(distinct col)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">计算指定字段的平均值，如果指定了 distinct 关键字，则对字段 col 去重后再计算</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">min(col)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">计算字段 col 的最小值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">max(col)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">计算字段 col 的最大值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">variance(col),var_pop(col)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字段col 的方差值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">var_samp(col)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字段 col 的无偏样本方差</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">stddev_pop(col)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字段 col 的标准偏差</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">stddev_samp(col)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字段 col 的无偏样本标准差</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">covar_pop(col1,col2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回两个字段对的总体协方差</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">covar_samp(col1,col2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回两个字段对的样本协方差</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">corr(col1,col2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">计算两个字段对的皮尔逊积矩相关系数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">percentile(bigint col,p)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字段 col 的第 p 百分位数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">array&lt;double&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">percentile(bigint col,array(p1,[,p2]&#8230;&#8203;))</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字段 col 的第p1,p2百分位数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">percentile_approx(double col,p[,B])</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字段 col 的第 p 个百分位概述，参数 B 控制概数的精确度，值越大，产生的概述越好，默认 B 的值为10000。当字段 col 的去重个数小于 B 值时，该函数返回准确的百分位数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">array&lt;double&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">percentile_approx(bigint col,array(p1,[,p2]&#8230;&#8203;)[,B])</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字段 col 的第p1,p2个百分位概述,参数 B 的定义同上</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">array&lt;struct{'x','y'}&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">histogram_numeric(col,b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 b 非均匀间隔箱体计算字段 col 的直方图数据，输出结果为一组双精度(x,y)值的数组，分别对应箱体的中心点和箱高。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">collect_set(col)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字段 col 的去重数据后的集合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">collect_list(col)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回字段 col 中有重复数据的集合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ntile(integer x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把一个有序分区分为 x 个成为桶的组里，在分区里，每一行记录对应一个桶的编号。这方便计算三分位数、四分位数、十分位数和百分位数等统计功能</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_内置的表生成函数">5.3. 内置的表生成函数</h3>
<div class="paragraph">
<p>标准的用户定义函数,比如 concat() ，是接受单行记录输入，然后输出一个单行记录。与此想法，表生成函数(UDTF) 则是把一行记录转换为多行记录。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">返回类型</th>
<th class="tableblock halign-left valign-top">函数名</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">N rows</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">explode(ARRAY)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把数组的每一个元素当做一行输出</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">N rows</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">explode(MAP)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把 Map 的每一个 key-value 对当做一行记录输出，集中 key 和 value 分别形成一列</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">inline(ARRAY&lt;struct[,struct]&gt;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把一个结构数组导出到一个表里</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">explode(ARRAY&lt;type&gt; a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对 a 的每一个元素当做一行输出</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tuple</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">parse_url_tuple(url,p1,p2,&#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类似 parse_url()函数，不过是依据给出的 pattern，把对应的结果一次性输出到一个元组里。有效 pattern 名称为 HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, USERINFO, QUERY:&lt;KEY&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">N rows</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">posexplode(ARRAY)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类似 explode() 函数，不过该函数的输出结果中包含了元素的下标位置，也就是输出的一个(pos,value) 组成的元组</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">N rows</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">stack(int n,v_1,v_2,&#8230;&#8203;,v_k)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把 v_1,v_2,&#8230;&#8203;,v_k 个元素分到 n 行记录里，每一行有 k/n 个元素。n 必须是常数</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hive_tuning">6. Hive 性能调优</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这一章我们讨论 Hive 性能优化的常用方法。</p>
</div>
<div class="sect2">
<h3 id="_hive_架构概述">6.1. Hive 架构概述</h3>
<div class="paragraph">
<p>提交到 Hive 的 SQL 查询并开始执行大致需要经过以下步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Hive 编译查询</p>
</li>
<li>
<p>执行引擎&#8201;&#8212;&#8201;比如 Tez 或 MapReduce&#8201;&#8212;&#8201;执行编译后的查询</p>
</li>
<li>
<p>资管管理器&#8201;&#8212;&#8201;比如 YARN&#8201;&#8212;&#8201;分配资源给应用程序</p>
</li>
<li>
<p>与查询相关的数据从 HDFS 中获取。支持的数据格式有 ORC，AVRO，Parquet 以及纯文本</p>
</li>
<li>
<p>查询结果集通过 JDBC/ODBC 等返回</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>上述执行过程的简单流程图如下：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hive-tuning-56a68.png" alt="SQL查询执行过程">
</div>
</div>
<div class="paragraph">
<p>更详细的流程图如下：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hive-tuning-f6840.png" alt="SQL查询执行详细过程">
</div>
</div>
<div class="paragraph">
<p>下面的内容解释上述查询执行架构的主要部分：</p>
</div>
<div class="paragraph">
<div class="title">Hive 客户端</div>
<p>我们可以使用支持 JDBC/ODBC 的工具来连接 Hive，比如 Microstrategy, Tableau, BusinessObject 或者自行开发的应用程序。
同时我们也可以使用命令行工具来连接到 Hive，比如 Hive-Cli,Beeline 等。</p>
</div>
<div class="paragraph">
<div class="title">SQL in Hive</div>
<p>Hive 支持大量的标准 SQL 语法，已经发布的 Hive 2.0 完全支持 ANSI 标准 SQL</p>
</div>
<div class="paragraph">
<div class="title">HiveServer2</div>
<p>通过 JDBC/ODBC 连接的 Hive 客户端是和 HiveServer2 进行通信，HiveServer2可以处理多用户会话，每一个会话使用不同的线程。
HiveServer2有一个内嵌的 metastore，用来执行下面的任务：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从 Hive Metastore 获取统计和模式</p>
</li>
<li>
<p>编译查询</p>
</li>
<li>
<p>生成查询执行计划</p>
</li>
<li>
<p>提交查询执行计划</p>
</li>
<li>
<p>返回查询结果集给客户端</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">Tez Execution</div>
<p>查询编译后，HiveServer2生成一个 Tez 图提交给 YARN。Tez 应用管理器(AM) 监控该查询的运行情况</p>
</div>
<div class="paragraph">
<div class="title">Security</div>
<p>当提交一个查询时，Hive 执行标准 SQL 安全检查，当连接认证通过后，服务进行授权检查已确保用户提交的查询说访问的数据库、表、字段、视图以及其他资源都是有权限的。
安全也可以通过第三方组件，比如 Ranger 来增加安全机制。</p>
</div>
<div class="paragraph">
<div class="title">文件格式</div>
<p>Hive支持相当多的文件格式，通过还可以通过开发 SerDes(Serializers，Deserializers) 接口来支持新的文件格式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_hive_高性能最佳实践">6.2. Hive 高性能最佳实践</h3>
<div class="paragraph">
<p>以下章节描述提升 Hive 性能的最佳实践</p>
</div>
<div class="sect3">
<h4 id="_使用_tez_查询引擎">6.2.1. 使用 Tez 查询引擎</h4>
<div class="paragraph">
<p>Tez 查询引擎，用来替代传统的 MapReduce，它有着更高的效率。Tez应该是你首选的查询引擎，虽然 Spark SQL 也宣称执行效率高，但是所支持的 SQL 标准不如前者。</p>
</div>
<div class="paragraph">
<p>下面是 Tez 和 MapReduce 两种查询殷勤的执行流程比较</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hive-tuning-8642d.png" alt="Tez vs MapReduce">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用_orc_文件格式">6.2.2. 使用 ORC 文件格式</h4>
<div class="paragraph">
<p>ORC 文件格式提供以下好处：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>高压缩率</strong>: 以列的方式存储，并进行压缩，这样可以使得读写磁盘的次数减少。面向列的格式也是对于向量优化的一种理想格式</p>
</li>
<li>
<p><strong>快速读</strong>: ORC 内建索引,min/max 值，以及其他聚合函数的结果，这使得获取这些结果时不需要真正读取数据。另外，谓词下推使得过滤只需要很少的行。而且内建的布隆过滤(Bloom filters)进一步要返回的行数</p>
</li>
<li>
<p><strong>大规模部署证明</strong>: Facebook 在超过3000 PB 的数据集上部署了 ORC 格式。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hive-tuning-67850.png" alt="ORC 文件格式">
</div>
</div>
<div class="paragraph">
<div class="title">指定 ORC 作为存储格式</div>
<p>创建表时，可以指定存储格式以及压缩算法，类似下面这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">CREATE TABLE addresses (
   name string,
   street string,
   city string,
   state string,
   zip int
   ) STORED AS orc tblproperties ("orc.compress"="Zlib");</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">切换存储格式到 ORC</div>
<p>我们可以从存在的表读取数据，然后以 ORC 格式拷贝存储，类似下面的命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">CREATE TABLE a_orc STORED AS ORC AS SELECT * FROM a;</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">高级设置</div>
<p>ORC 的大部分属性不需要我们去修改，但是，对应特定的场景，你可以需要修改以下属性来满足业务特性。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">选项</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">注释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">orc.compress</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZLIB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">压缩类型(NONE,ZLIB,SNAPPY)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">orc.compress.size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">262,144</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个压缩块的字节数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">orc.strip.size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">268,435,456</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个条带的字节数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">orc.row.index.stride</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10,0000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">两个索引条目中间的行数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">orc.create.index</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置是否创建行索引</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">orc.bloom.filter.columns</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许布隆过滤的字段，多个字段用逗号分隔</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">orc.bloom.filter.fpp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.05</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">针对布隆过滤的假阳性概率(False Positive Probability, FPP)，值在0和1之间</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_使用列统计和_cbo">6.3. 使用列统计和 CBO</h3>
<div class="paragraph">
<p>基于成本的优化器(Cost-Based Optimizer, CBO) 可以产生更有效率的查询计划。在 Hive 中，CBO 默认启用，但它需要利用列统计来针对表产生执行计划。
列统计是高成本计算，因此不会自动执行。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">启用 CBO</dt>
<dd>
<p>如果你的 Hive 还没有启动 CBO，在 <code>hive-site.xml</code> 文件配置对应的属性，也可以在Hive 中执行下面的命令启用：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">SET hive.cbo.enable=true;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">生成统计</dt>
<dt class="hdlist1">CBO同时需要表级和列级的统计</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>表级统计： 针对表级的统计收集应该总是运行，确保下面的属性已经配置在 <code>hive-site.xml</code> 文件中</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">SET hive.stats.autogather=true;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果已经存在的表没有做统计收集，可以直接执行下面的命令来进行收集：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ANALYZE TABLE &lt;table_name&gt; COMPUTE STATISTICS;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>列级统计（非常关键）
列级统计非常耗时，因此不会自动执行。对于已经存在的表，我们可以使用下面的命令来执行列统计收集：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>ANALYZE TABLE &lt;table_name&gt; COMPUTE STATISTICS for COLUMNS;</pre>
</div>
</div>
<div class="paragraph">
<p>对于新增的分区，只需要对该分区做列统计收集即可。假设一个表的分区字段为&#8217;col1'，增加了一个值为&#8217;x' 的分区，那么可以执行下面的命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">ANALYZE TABLE &lt;table_name&gt; PARTITION(col1='x') COMPUTE STATISTICS for COLUMNS;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_巧妙设计数据存储">6.4. 巧妙设计数据存储</h3>
<div class="paragraph">
<p>下面是 Hive 的数据存储抽象层图</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hive-tuning-96455.png" alt="Hive Data Abstractions">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">分区</dt>
<dd>
<p>Hive 里的表经常使用分区，大部分情况下，表使用采取日期/时间进行分区，这样可以每天的数据载入到对应的一个分区中。
不过在大规模部署环境中，这种分区方式将会有成千上万个分区，每个分区在物理上对应一个 HDFS 的上目录。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>如果一个查询刚好可以使用分区字段进行过滤，那么使用分区能显著提升查询效率。</p>
</div>
<div class="paragraph">
<p>分区字段并不在表的主体中，它称之为“虚拟字段”，不过对于 SQL 查询而言，它和普通字段并无区别。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">create table sale(id int,amount decimal)
  partitioned by (xdate string, state string);</code></pre>
</div>
</div>
<div class="paragraph">
<p>要插入数据到上述表中，分区键可以在载入数据的最后指定</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">insert into sale(xdate='2016-03-08', state='CA')
  select * from staging_table
  where xdate = '2016-03-08' and state = 'CA';</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有分区键，那么将会采取动态分区方式加载数据，不过效率会比较低。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">桶(Buckets)</dt>
<dd>
<p>表或分区可以进一步划分成桶，这等于进一步细化的分区表的分区区间。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_使用队列来更好的管理负载">6.5. 使用队列来更好的管理负载</h3>
<div class="paragraph">
<p>队列是用来管理多个负载的主要方法。队列可以提供负载隔离，对不同的负载提供不同的容量担保。队列还可以针对不同的负载来满足不同的服务水平协议(SLA)。</p>
</div>
<div class="paragraph">
<p>在每一个队列里，你可以允许一个多个会话同时存在。这些会话共享资源可以进行互操作。</p>
</div>
<div class="paragraph">
<p>下图是一个集群配置队列示意图</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hive-tuning-38cad.png" alt="集群配置队列">
</div>
</div>
<div class="sect3">
<h4 id="_配置_hive_的对队列">6.5.1. 配置 Hive 的对队列</h4>
<div class="paragraph">
<p>对于多负载或多应用程序，推荐使用多个 HiveServer2 实例。每一个 HiveServer2 有自己的独立的针对 Hive 和 Tez 的配置。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hive-tuning-ab495.png" alt="Hive 配置多队列">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">安装第二个 HiveServer2 实例</dt>
<dd>
<p>下图显示了多个 HiveServer2 实例</p>
</dd>
</dl>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hive-tuning-e278c.png" alt="hive tuning e278c">
</div>
</div>
<div class="paragraph">
<p>以下是手工安装第二个 HiveServer2 实例的步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果安装第二个实例的节点不在当前集群范围内，需要执行下面的命令把 HDFS 相关的软件包都安装上</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">yum install hive hcatalog hadoop hadoop-hdfs hadoop-libhdfs
        hadoop-yarn hadoop-mapreduce hadoop-client openssl</code></pre>
</div>
</div>
<div class="paragraph">
<p>否则，只需要安装 Hive 相关的包即可</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sql">yum install hive hcatalog</code></pre>
</div>
</div>
</li>
<li>
<p>从原始 HiveServer2 节点上拷贝下面的配置到新的节点上</p>
<div class="ulist">
<ul>
<li>
<p>/etc/hive/conf 下的 hive-site.xml,hiveserver2-site.xml</p>
</li>
<li>
<p>/etc/hadoop/conf 下的 core-site.xml，hdfs-site.xml，mapred-site.xml 以及 yarn-site.xml</p>
</li>
</ul>
</div>
</li>
<li>
<p>拷贝针对 Hive Metastore 的数据库 JDBC 驱动包到新节点上</p>
</li>
<li>
<p>启动 HiveSever2 服务：</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell">su $HIVE_USER
/usr/bin/hiveserver2 -hiveconf hive.metastore.uris=" "
-hiveconf hive.log.file=hiveserver2.log
&gt;$HIVE_LOG_DIR/hiveserver2.out 2
&gt;$HIVE_LOG_DIR/hiveserver2.log &amp;</code></pre>
</div>
</div>
</li>
<li>
<p>通过 Beeline 等工具连接到新的 HiveServer2 实例</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell">/usr/bin/beeline -u jdbc:hive2://&lt;hive.server.full.hostname&gt;:10000 $HIVE_USER password org.apache.hive.jdbc.HiveDriver</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_创建和配置_yarn_容量调度队列">6.5.2. 创建和配置 YARN 容量调度队列</h4>
<div class="paragraph">
<p>容量调度队列可以用来在用户和组中间分配集群资源。相关配置文件为 <code>conf/capacity-scheduler.xml</code></p>
</div>
<div class="paragraph">
<p>下面的配置例子演示了如何配置容量调度队列。该例子把队列分成短期运行和长期运行两个分离的队列：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>hive1</strong>&#8201;&#8212;&#8201;该队列运行那些耗时短的查询，分配整个资源的50%</p>
</li>
<li>
<p><strong>hive2</strong>&#8201;&#8212;&#8201;该队列运行那些耗时长的查询，分配整个资源的50%</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>修改配置文件，增加以下内容</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ini">yarn.scheduler.capacity.root.queues=hive1,hive2
yarn.scheduler.capacity.root.hive1.capacity=50
yarn.scheduler.capacity.root.hive2.capacity=50</code></pre>
</div>
</div>
<div class="paragraph">
<p>还可以配置使用者使用限定</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ini">yarn.scheduler.capacity.root.hive1.maximum-capacity=50
yarn.scheduler.capacity.root.hive2.maximum-capacity=50
yarn.scheduler.capacity.root.hive1.user-limit=1
yarn.scheduler.capacity.root.hive2.user-limit=1</code></pre>
</div>
</div>
<div class="paragraph">
<p>设置 <strong>maximum-capacity</strong> 到50表示限制可以最多可以使用到50%，注意这是一个硬限制(hard limit)。user-limit 配置为1表示单个用户最多可以使用1倍的队列配置容量。</p>
</div>
</div>
<div class="sect3">
<h4 id="_配置改变时刷新_yarn_队列">6.5.3. 配置改变时刷新 YARN 队列</h4>
<div class="paragraph">
<p>通过命令行接口可以在不重启 YARN 的情况下改变 YARN 的容量配置。假定你修改了 <code>conf/capacity-scheduler.xml</code>，那么执行下面的命令即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell">yarn rmadmin -refreshQueues</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_为_tdp2_7_配置交互式队列">6.5.4. 为 TDP2.7 配置交互式队列</h4>
<div class="paragraph">
<p>在 TDP2.7 产品中，我们可以使用 Tuatara(GUI 工具)来配置交互式队列。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">配置 Tez 容器重用</dt>
<dd>
<p>访问 <code>Tuatara&#8594;Tez&#8594;配置&#8594;高级</code> 或者直接修改 <code>tez-site.xml</code> 可以改变 Tez 的配置。启动 Tez 重用容器针对每一个任务的内存开销和资源分配，从而提升性能。
其原理是针对特定的时间范围内配置为一定保留量的队列容量，从而使得接下来的查询可以很快运行。
要注意的是该设置时全局性的，因为为了确保该配置仅影响一个应用程序，我们必须在隔离的 HiveServer2 节点上使用独立的 <code>tez-site.xml</code>。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在一个繁忙的集群列队中，越少的交互会获得越好的性能，比如交互查询所持续的时间不超过5分钟。对于不太繁忙的队列或者我们觉得时间是一个重要的参考点时，
一个交互查询的时间也不要超过30分钟。</p>
</div>
<div class="paragraph">
<p>在 <code>tez-site.xml</code> 进行下列配置来启用容器重用：</p>
</div>
<div class="ulist horizon">
<ul class="horizon">
<li>
<p><strong>Tez Application Master Waiting Period</strong>(/秒)&#8201;&#8212;&#8201;指定 Tez AM 在关闭已经提交的 DAG 任务前等待的时间量。假定我们要设置为15分钟，即 15*60 = 900 秒</p>
<div class="paragraph">
<p><code>tez.session.am.dag.submit.timeout.secs=900</code></p>
</div>
</li>
<li>
<p><strong>Tez min.held-containers</strong>&#8201;&#8212;&#8201;指定AM 启动和查询运行完毕后保留的容器的最小数量。如果一个 AM 保留太多的容器，那么它会放弃一些容器直到降低到设定的水平。配置参数如下</p>
<div class="paragraph">
<p><code>tez.am.session.min.hel-containers=5</code></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">HiveServer2 配置</dt>
<dd>
<p>HiveServer2 的配置可以通过 <code>Tuatara&#8594;Hive&#8594;配置&#8594;高级配置</code> 标签来进行修改，也可以直接编辑 <code>hive-site.xml</code> 文件。修改后，必须重启 HiveServer2 才能生效。</p>
</dd>
</dl>
</div>
</li>
<li>
<p><strong>Hive Execution Engine</strong>&#8201;&#8212;&#8201;设置为 "tez":</p>
<div class="paragraph">
<p><code>hive.execution.engine=tez</code></p>
</div>
</li>
<li>
<p><strong>Enable Default Sessions</strong>&#8201;&#8212;&#8201;启动该选项后，表示所有的会话默认都会使用 tez 引擎。</p>
<div class="paragraph">
<p><code>hive.server2.tez.initialize.default.session=true</code></p>
</div>
</li>
<li>
<p><strong>Sepcify HiveServer Queues</strong>&#8201;&#8212;&#8201;配置多个队列时，队列名之间用逗号(,)分隔。比如像下面这样</p>
<div class="paragraph">
<p><code>hive.server2.tez.default.queues=hive1,hive2</code></p>
</div>
</li>
<li>
<p><strong>Set the Number of Sessions in Each Queue</strong>&#8201;&#8212;&#8201;设置每个队列的会话数</p>
<div class="paragraph">
<p><code>hive.server2.tez.sessions.per.default.queue=1</code></p>
</div>
</li>
<li>
<p><strong>Set enable.doAs</strong> &#8201;&#8212;&#8201;设置为 false 时，Hive提交给 YARN 的任务的运行用户不是独立的系统用户，而是运行 HiveServer2 的用户。该项设置提升了安全以及容器重用</p>
<div class="paragraph">
<p><code>hive.server2.enable.doAs=false</code></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>当 <code>doAs</code> 设置为 false 时，这意味着所有运行 hive 任务的用户都一样，他们就能共享资源。否则，YARN 是无法在把资源在不同用户之间共享的。
这样当 hive 执行所有的查询时，tez 为一个查询打开一个会话，并保留所有的资源给下一个查询而不用重新分配。</p>
</dd>
<dt class="hdlist1">为提升并发用户数调整配置</dt>
<dd>
<p>当并发用户数提升后，队列的最小数保持不变，增加每个队列的会话数。比如，对5-10个并发用户而言，2-5个队列，每个队列1-2个会话比较合适。以下是配置示例：</p>
</dd>
</dl>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>hive.server2.tez.default.queues=hive1,hive2,hive3
hive.server2.tez.sessions.per.default.queue=2</pre>
</div>
</div>
<div class="paragraph">
<p>如果并发用户数提升到15，那么可以考虑使用5个队列，每个对了3个会话。</p>
</div>
<div class="paragraph">
<p>下表给出了并发用户数与队列和会话的配置推荐</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">用户数</th>
<th class="tableblock halign-left valign-top">并发用户数</th>
<th class="tableblock halign-left valign-top">队列数</th>
<th class="tableblock halign-left valign-top">会话数/队列</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">50</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2-5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1-2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">150</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_为_tdp2_7_配置混合负载队列">6.5.5. 为 TDP2.7 配置混合负载队列</h4>
<div class="paragraph">
<p>如果队列包含了交换式和批量的工作负载，我们可以设置队列基于使用的方式。</p>
</div>
<div class="paragraph">
<p>一般来说，针对交互式查询的调整并不会影响批量查询。所以两种类型的查询可以共存在同一个队列中。
当然，我们也可以针对交换式和批量的查询分成隔离的队列，比如50%的资源分配给批量查询，交换式查询分成2个队列，每个队列占比25%。配置如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ini">yarn.scheduler.capacity.root.queues=default,hive1,hive2
yarn.scheduler.capacity.root.default.capacity=50
yarn.scheduler.capacity.root.hive1.capacity=25
yarn.scheduler.capacity.root.hive2.capacity=25</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_内存配置指南">6.6. 内存配置指南</h3>
<div class="paragraph">
<p>内存配置似乎很简单，但是很重要，如果配置不恰当，任务可能运行失败或者没有足够的资源运行。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">YARN 内存配置</dt>
<dd>
<p>YARN 会考虑到集群中每台服务器的所有可用计算资源。基于这些可用资源，YARN会协调运行在集群中的应用所需要的资源，比如 MapReduce。然后 YARN 通过分配容器提供给每一个应用的处理能力。
在 YARN 里，容器是处理能力的基本单位。它封装了所需要的资源元素（比如内存，CPU 等等）</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在 Hadoop 集群中，平衡内存、CPU 和磁盘资源的使用很重要，以避免任务运行是不受这些资源的限制。
通常来说，每核每磁盘2个容器时集群资源利用的最佳配置。</p>
</div>
</div>
<div class="sect2">
<h3 id="_查询优化">6.7. 查询优化</h3>

</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
最后更新时间 2016-12-21 16:56:30 中国标准时间
</div>
</div>
</body>
</html>